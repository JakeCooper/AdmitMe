// Super simple require system
(function () {

// Store our repository in private variables in this closure.
var defs = {},
    modules = {};

// When the user defines a module's setup function, store it here.
define = function define(name, fn) {
  defs[name] = defs[name] || fn;
};

var realRequire = global.require;
// The first time a module is used, it's description is executed and cached.
require = function require(name) {
  if (modules.hasOwnProperty(name)) return modules[name];
  if (defs.hasOwnProperty(name)) {
    var exports = modules[name] = {};
    var module = {exports:exports};
    var fn = defs[name];
    fn(module, exports);
    return modules[name] = module.exports;
  }
  if (realRequire) {
    return realRequire(name);
  }
  throw new Error("Can't find module " + name);
};

}());


define('c9.ide.collab/server/collab-server.js', function (module, exports) {


"use strict";
var Fs = require("fs");
var Path = require("path");
var net = require("net");
var Stream = require("stream").Stream;
var crypto = require('crypto');
var events = require("events");
var exists = Fs.exists || Path.exists;

var localfsAPI; // Set on VFS register
var DEFAULT_NL_CHAR_FILE = "\n";
var DEFAULT_NL_CHAR_DOC = "";
var MAX_WRITE_ATTEMPTS = 3;

// If you leave unsaved changes for more than 24 hours and the file on disk changes 
// those unsaved changes will be lost. Don't want them hanging around forever. 
var UNSAVED_CHANGE_EXPIRY_TIME = 24 * 60 * 60 * 1000; 

// Models
var User, Document, Revision, Workspace, ChatMessage;
var basePath;
var PID;
var dbFilePath;

// Cache the workspace state got from the database
var cachedWS;
var cachedUsers;

var totalWriteAttempts = 0;
var lastFailedWrite = 0;
var resettingDatabase = false;

var isMaster = false;

var Sequelize;
var nodePath = getHomeDir() + "/.c9/node_modules";

var debug = false;


function getHomeDir() {
    return process.env.HOME;
}

function getProjectWD() {
    var env = process.env;
    var pidStr = env.BASE_PROC ? "" : String(PID);
    return Path.resolve(env.BASE_PROC || env.HOME, ".c9", pidStr);
}

/**
 * Checks if the collab server required modules are installed
 * npm: sqlite3 & sequelize
 */
function installServer(callback) {
    function checkInstalled(root) {
        try {
            require(root + "sqlite3");
            Sequelize = require(root + "sequelize");
            return true;
        } catch (err) {
            console.error(err);
            return false;
        }
    }
    if (!Sequelize && !checkInstalled(nodePath + "/") && !checkInstalled("")) {
        var err = new Error("[vfs-collab] Couldn't load node modules sqlite3 and sequelize "
            + "from " + nodePath + " "
            + "node version: " + process.version + "; "
            + "node execPath " + process.execPath
            );
        err.code = "EFATAL";
        return callback && callback(err);
    }
    callback && callback();
}

/**
 * Wrap Sequelize callback-style to NodeJS"s standard callback-style
 */
function wrapSeq(fun, next) {
    return fun.then(function () {
        next.apply(null, [null].concat(Array.prototype.slice.apply(arguments)));
    }, function (err) {
        checkDBCorruption(err, next);
    });
}

/** 
 * Check for DB corruption errors in SQL Query and if we have some then run initDB again
 **/
function checkDBCorruption (err, callback) {
    if (!err || !isMaster) {
        return callback();
    }
    
    var errMessage = err && err.message ? " " + err.message : "";
    
    // Ignore duplicate column name errors, there is no way to stop them happening in ALTER TABLE syntax
    if (errMessage.match(/duplicate column name/)) {
        return callback(); 
    }
    
    broadcast({
        type: "ERROR",
        err: new Error("Collab encountered error" + errMessage),
        collabError: err
    });
    
    console.error("[vfs-collab] CheckDBCorruption encountered error: ", err);
    if (err.code === "SQLITE_CORRUPT" || err.code === "SQLITE_NOTADB" || err.code === "SQLITE_IOERR") {
        console.error("[vfs-collab] found a corrupted database - backing up and starting with a fresh collab database");
        broadcast({
            type: "ERROR",
            err: new Error("Collab database corrupt")
        });
        return resetDB(callback); 
    }
    
    if (err.code == "SQLITE_READONLY") {
        if (lastFailedWrite < (Date.now() - 5000)) {
            totalWriteAttempts = 0;
        }
        totalWriteAttempts++;
        lastFailedWrite = Date.now();
        if (totalWriteAttempts >= MAX_WRITE_ATTEMPTS) {
            console.error("[vfs-collab] Failed to write " + MAX_WRITE_ATTEMPTS + " times, checking if database is corrupt");
            
            // If the database is really corrupt this should return a corruption error which will be caught above
            var sequelize = connectToDB();
            wrapSeq(sequelize.query("PRAGMA synchronous = 0;"), function() {
                if (sequelize.close) {
                    sequelize.close();
                }
            }); 
        }
    }
    
    callback(err); 
}

function connectToDB() {
    var MAX_LOG_LINE_LENGTH = 151;

    dbFilePath = dbFilePath || Path.join(getProjectWD(), "collab.db");
    installServer();
    var sequelize = new Sequelize("c9-collab", "c9", "c9-collab-secret", {
        // the sql dialect of the database
        dialect: "sqlite",
        omitNull: true,
        storage: dbFilePath,
        // capture only the most important pieces of a sql statement or query
        logging: function (log) {
            if (!debug)
                return;

            var lines = log.split(/\r\n|\n|\r/);
            var firstLine = lines[0];
            firstLine = firstLine.length < MAX_LOG_LINE_LENGTH ? firstLine : (firstLine.substring(0, MAX_LOG_LINE_LENGTH) + "...");
            var lastLine = lines[lines.length-1];
            lastLine = lastLine.length < MAX_LOG_LINE_LENGTH ? lastLine : (lastLine.substring(lastLine.length - MAX_LOG_LINE_LENGTH) + "...");
            console.error("[vfs-collab] DB", lines.length === 1
                ? (lines[0].length <= (2*MAX_LOG_LINE_LENGTH) ? lines[0] : (firstLine + lines[0].substring(Math.max(MAX_LOG_LINE_LENGTH, lines[0].length - MAX_LOG_LINE_LENGTH))))
                : (firstLine + " --- " + lastLine));
        },

        define: {
            // don"t use camelcase for automatically added attributes but underscore style
            // so updatedAt will be updated_at
            underscored: true,
            freezeTableName: false,
            charset: "utf8",
            collate: "utf8_general_ci",
            classMethods: {},
            instanceMethods: {}
        },

        // sync after each association (see below). If set to false, you need to sync manually after setting all associations. Default: true
        syncOnAssociation: true,

        // use pooling in order to reduce db connection overload and to increase speed
        // currently only for mysql and postgresql (since v1.5.0)
        pool: { maxConnections: 5, maxIdleTime: 30}
    });
    
    return sequelize;
}

/**
 * Initialize the collab server sqlite3 database
 *  - Define modules mapping to tables
 *  - Declare relationships
 *  - Sync sequelize modules
 *  - Create and cache the Workspace metadata
 *  - Set synchronous = 0 for fastest IO performance
 *  - Create indices, if not existing
 * 
 * @param {Boolean} readonly    Whether the intention is only to read from the
 *                              database (if true, initialization is skipped)
 * @param {Function} callback
 */
function initDB(readonly, callback) {
    var sequelize = connectToDB();

    Store.User = User = sequelize.define("User", {
        uid: { type: Sequelize.STRING, primaryKey: true },
        fullname: { type: Sequelize.STRING },
        email: { type: Sequelize.STRING }
    }, {
        timestamps: true
    });

    Store.Workspace = Workspace = sequelize.define("Workspace", {
        authorPool: { type: Sequelize.TEXT }, // Stringified JSON  - uid -> 1,2, ...etc.
        colorPool: { type: Sequelize.TEXT }, // Stringified JSON - uid --> "{r: 256, g: 0, b: 0}"
        basePath: { type: Sequelize.STRING, allowNull: false },
        migration: { type: Sequelize.INTEGER, defaultValue: 0 }
    }, {
        timestamps: true
    });

    Store.Document = Document = sequelize.define("Document", {
        id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true },
        path: { type: Sequelize.STRING, unique: true },
        contents: { type: Sequelize.TEXT },
        fsHash: { type: Sequelize.STRING },
        authAttribs: { type: Sequelize.TEXT }, // Stringified JSON
        starRevNums: { type: Sequelize.TEXT }, // Stringified JSON list of integers
        revNum: { type: Sequelize.INTEGER, defaultValue: 0 },
        created_at: { type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW },
        updated_at: { type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW },
        lastUpdate: { type: Sequelize.BIGINT, defaultValue: 0 },
        newLineChar: { type: Sequelize.STRING, defaultValue: DEFAULT_NL_CHAR_DOC }, // "" or "\n" or "\r\n"
    }, {
        timestamps: false
    });

    Store.Revision = Revision = sequelize.define("Revision", {
        id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true },
        operation: { type: Sequelize.TEXT }, // Stringified JSON Array - can be empty for rev:0
        author: { type: Sequelize.STRING }, // userId if exists, 0 in syncing operations, -1 in undo non authored text
        revNum: { type: Sequelize.INTEGER },
        created_at: { type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW },
        updated_at: { type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW }
    }, {
        timestamps: false
    });

    Store.ChatMessage = ChatMessage = sequelize.define("ChatMessage", {
        id: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true },
        text: { type: Sequelize.STRING },
        userId: { type: Sequelize.STRING, allowNull: false },
        timestamp: { type: Sequelize.DATE, allowNull: false, defaultValue: Sequelize.NOW }
    }, {
        timestamps: true
    });

    Document.hasMany(Revision);
    Revision.belongsTo(Document);
    
    if (readonly || !isMaster)
        return callback();

    // Add migrations here e.g. ALTER TABLE ... ADD COLUMN ...
    var migrations = [
        { query: "CREATE INDEX DocumentRevisionsIndex ON Revisions(document_id)", skipError: true },
        { query: "CREATE INDEX ChatMessageTimestampIndex ON ChatMessages(timestamp)", skipError: true },
        { query: "DELETE FROM Documents" },
        { query: "DELETE FROM Revisions" },
        { query: "ALTER TABLE Documents ADD COLUMN newLineChar VARCHAR(255)" },
        { query: "ALTER TABLE Documents ADD COLUMN lastUpdate BIGINT" }
    ];

    async.series([
        function(next) {
            // http://www.sqlite.org/pragma.html
            wrapSeq(sequelize.query("PRAGMA synchronous = 0;"), next);
        },
        // Document.drop(), // Cleanup on init
        // Revision.drop(), // Cleanup on init
        function(next) {
            wrapSeq(User.sync(), next);
        },
        function(next) {
            wrapSeq(Workspace.sync(), next);
        },
        function(next) {
            wrapSeq(sequelize.query("ALTER TABLE Workspaces ADD COLUMN migration INTEGER DEFAULT 0"), next.bind(null, null));
        },
        function(next) {
            wrapSeq(Document.sync(), next);
        },
        function(next) {
            wrapSeq(Revision.sync(), next);
        },
        function(next) {
            wrapSeq(ChatMessage.sync(), next);
        },
        function (next) {
            wrapSeq(Workspace.findOrCreate({id: 1}, {
                authorPool: "{}",
                colorPool: "{}",
                basePath: basePath,
                migration: migrations.length
            }), function(err, ws) {
                if (err)
                    return next(err);
                ws.authorPoolParsed = parseJSONField(ws.authorPool);
                ws.colorPoolParsed = parseJSONField(ws.colorPool);
                cachedWS = ws;
                next();
            });
        },
        function (next) {
            var migNum = cachedWS.migration || 0;
            if (migNum === migrations.length)
                return next();
            var migApplied = migNum;
            async.forEachSeries(migrations.slice(migNum - migrations.length), function (migration, next) {
                console.error("[vfs-collab] applying database migration:", migration.query);
                wrapSeq(sequelize.query(migration.query), function(err) {
                    if (err && !migration.skipError)
                        return next(err);
                    migApplied++;
                    cachedWS.migration = migApplied;
                    Store.saveWorkspaceState(cachedWS, next);
                });
            }, function(err) {
                if (cachedWS.migration != migrations.length)
                     err = (err ? (err + " -- ") : "") + "Not all migrations could be applied!";
                next(err);
            });
        }
    ], function(err) {
        if (!err)
            return callback();
        console.error("[vfs-collab] initDB attempt failed:", err);
        checkDBCorruption(err, callback);
    });
}

// parse json encoded several times
function parseJSONField(val) {
    try {
        while (typeof val == "string") {
            val = JSON.parse(val);
        }
    } catch(e) {
        console.error("[vfs-collab] parseJSONField failed:", val, e);
        val = {};
    }
    return val;
}

/** 
 * Resets the database back to default state deleting all collab changes. 
 * This is useful if the database somehow becomes corrupt and can no longer be written to
 **/

function resetDB(callback) {
    if (resettingDatabase || !isMaster) return callback();
    console.error("[vfs-collab] resetting collab database");
    resettingDatabase = true;
    Fs.rename(dbFilePath, dbFilePath + ".old", function (err) {
        if (err && err.code !== "ENOENT") {
            resettingDatabase = false; 
            return callback(err);
        }
        
        initDB(false, function() {
            resettingDatabase = false;     
            broadcast({
                type: "RESET_DB",
            });
            callback();
        });
    });
}

/**************** operations.js ******************/
var operations = (function() {
/**
 * Get a diff operation to transform a text document from: `fromText` to `toText`
 *
 * @param {String} fromText
 * @param {String} toText
 * @return {Operation} op
 */
function operation(fromText, toText) {
    var dmp = new diff_match_patch();
    var diffs = dmp.diff_main(fromText, toText);
    dmp.diff_cleanupSemantic(diffs);
    var d, type, val;
    var op = [];
    for (var i = 0; i < diffs.length; i++) {
        d = diffs[i];
        type = d[0];
        val = d[1];
        switch(type) {
            case DIFF_EQUAL:
                op.push("r" + val.length);
            break;
            case DIFF_INSERT:
                op.push("i" + val);
            break;
            case DIFF_DELETE:
                op.push("d" + val);
            break;
        }
    }
    return op;
}

// Simple edit constructors.

function insert(chars) {
    return "i" + chars;
}

function del(chars) {
    return "d" + chars;
}

function retain(n) {
    return "r" + String(n);
}

/**
 * Return the type of a sub-edit
 *
 * @param  {String} edit
 * @return {String} type of the operation
 */
function type(edit) {
    switch (edit[0]) {
    case "r":
        return "retain";
    case "d":
        return "delete";
    case "i":
        return "insert";
    default:
        throw new TypeError("Unknown type of edit: ", edit);
    }
}

/**
 * Return the value of a sub-edit
 *
 * @param  {String} sub-edit
 * @return the value of the operation
 *   - Retain: the number of characters to retain
 *   - Insert/Delete: the text to insert or delete
 */
function val(edit) {
    return type(edit) === "retain" ? ~~edit.slice(1) : edit.slice(1);
}

/**
 * Return the length of a sub-edit
 *
 * @param  {String} edit
 * @return {Number} the length of the operation
 *   - Retain: the number of characters to retain
 *   - Insert/Delete: the text length to insert or delete
 */
function length(edit) {
    return type(edit) === "retain" ? ~~edit.slice(1) : edit.length - 1;
}

/**
 * Split a sub-edit on a index: idx
 *
 * @param  {String} edit
 * @return [{String}] an array of length 2 of the sub-operaion splitted to 2 operaions
 */
function split(edit, idx) {
    if (type(edit) === "retain") {
        var rCount = ~~edit.slice(1);
        return [
            "r" + idx,
            "r" + (rCount - idx)
        ];
    }
    else {
        return [
            edit[0] + edit.substring(1, idx + 1),
            edit[0] + edit.substring(idx + 1)
        ];
    }
}

/**
 * Pack an operation to a minimal operation
 *
 * @param  {Operation} op
 * @return {Operation} packed
 */
function pack(op) {
    var packed = op.slice();
    var i = 0;
    while (i < packed.length - 1) {
        if (packed[i][0] === packed[i+1][0])
            packed.splice(i, 2, packed[i][0] + (val(packed[i]) + val(packed[i+1])));
        else
            i++;
    }
    return packed;
}

/**
 * Inverse an operation to undo revert its effect on a document
 *
 * @param  {Operation} op
 * @return {Operation} inversed
 */
function inverse(op) {
    var edit, t, v, inversed = new Array(op.length);
    for (var i = 0, el = op.length; i < el; i++) {
        edit = op[i];
        t = type(edit);
        v = val(edit);
        switch (t) {
            case "retain":
                inversed[i] = op[i];
                break;
            case "insert":
                inversed[i] = del(v);
                break;
            case "delete":
                inversed[i] = insert(v);
                break;
        }
    }
    return inversed;
}

return {
    insert: insert,
    del: del,
    retain: retain,
    type: type,
    val: val,
    length: length,
    split: split,
    pack: pack,
    operation: operation,
    inverse: inverse
};

})();

/**************** apply.js ******************/

function OTError(expected, actual) {
    var err = new Error("OT removed text mismatch");
    err.expected = expected;
    err.actual = actual;
    err.code = "EMISMATCH";
    return err;
}

/**
 * Apply an operation on a string document and return the resulting new document text.
 *
 * @param  {Opeartion} op - e.g. ["r2", "iabc", "r12"]
 * @param  {String} doc
 * @return {String} newDoc
 */
 function applyContents(op, doc) {
    var val, newDoc = "";
    for (var i = 0, len = op.length; i < len; i += 1) {
        val = op[i].slice(1);
        switch (op[i][0]) {
        case "r": // retain
            val = Number(val);
            newDoc += doc.slice(0, val);
            doc = doc.slice(val);
            break;
        case "i": // insert
            newDoc += val;
            break;
        case "d": // delete
            if (doc.indexOf(val) !== 0)
                throw new OTError(val, doc.slice(0, 10));
            else
                doc = doc.slice(val.length);
            break;
        default:
            throw new TypeError("Unknown operation: " + operations.type(op[i]));
        }
    }
    return newDoc;
}


/**************** author_attributes.js ******************/
/**
 * This is a specifically designed data structure that tends to behave as a relaxed B-Tree
 * to optimize author attributes processing time, disk usage and network overhead
 *
 * It optimizes on two main factors:
 * - insert/delete/traversal/find time: The B-tree try to maintain a minimal depth, so minimal processing needed for those operations: O(log with base minKeySize)
 * - Parsing/Stringification time and disk usage: the nodes are implemented as arrays with the first element
 *     indicating the number of entries in the node
 *
 * @param minKeySize - the minimum number of entries in a node
 * @param maxKeySize - the maximum number of entries in a node
 *
 * @author Mostafa
 * @author Harutyun
 */
function AuthorAttributes(minKeySize, maxKeySize) {
    // 2 * x ---> [length, [value]]
    minKeySize = minKeySize || 20; // 4
    maxKeySize = maxKeySize || (5 * minKeySize); // 8

    function addValue(nodes, index, startI, length, id) {
        var i = startI;
        var len = nodes[i];
        var val = nodes[i+1];
        if (index < 0 || index > len)
            throw new Error("Invalid index passed!");

        if (val === id) {
            nodes[i] += length;
        } else if (index === len) {
            if (nodes[i+3] == id)
                nodes[i+2]+=length;
            else
                nodes.splice(i + 2, 0, length, id);
        } else if (index === 0) {
            if (nodes[i-1] == id)
                nodes[i-2] += length;
            else
                nodes.splice(i , 0, length, id);
        } else {
            nodes.splice(i, 2, index, val, length, id, len - index, val);
        }
    }

    function split(parent, nodes, pos) {
        var splitPos = (nodes.length >> 2) << 1;
        var leftLen = 0, rightLen = 0;
        var right = nodes.splice(splitPos, splitPos + 2);

        for (var i = 0; i < right.length; i += 2)
            rightLen += right[i];

        if (parent) {
            parent.splice(pos + 2, 0, rightLen, right);
            parent[pos] -= rightLen;
        } else {
            var left = nodes.splice(0, splitPos + 2);
            for (var i = 0; i < left.length; i += 2)
                leftLen += left[i];
            nodes.push(leftLen, left, rightLen, right);
        }
    }

    function insert(nodes, index, length, id) {
        if (nodes.length === 0) {
            nodes.push(length, id);
            return;
        }
        var spilled = _insert(nodes, index, length, id);
        if (spilled)
            split(null, nodes, null);
        // sanityCheck(nodes)
    }

    function _insert(nodes, index, length, id) {
        for (var i = 0; i < nodes.length; i += 2) {
            var len = nodes[i];
            if (index <= len) {
                var node = nodes[i+1];
                if (Array.isArray(node)) {
                    nodes[i] += length;
                    var spilled = _insert(node, index, length, id);
                    if (spilled)
                        split(nodes, nodes[i+1], i);
                }
                else {
                    addValue(nodes, index, i, length, id);
                }
                return nodes.length > maxKeySize;
            }
            index -= len;
        }
    }

    function remove(nodes, index, length) {
        var removedTotal = 0;
        for (var i = 0; i < nodes.length; i += 2) {
            var len = nodes[i]; // node.length
            var ch = nodes[i + 1];
            var removed;
            if (index <= len) {
                if (Array.isArray(ch))
                    removed = remove(ch, index, length);
                else
                    removed = Math.max(0, Math.min(length, len - index));

                nodes[i] -= removed; // node.length
                length -= removed;
                removedTotal += removed;
                if (!nodes[i]) {
                    nodes.splice(i, 2);
                    i -= 2;
                }
                else if (Array.isArray(ch) && ch.length < minKeySize &&
                    (ch.length + nodes.length) <= maxKeySize) {
                    // Move elements from child to parent
                    nodes.splice.apply(nodes, [i, 2].concat(ch));
                }
                if (!length)
                    break;
                index = 0;
            }
            else {
                index -= len;
            }
        }

        for (var j = 0; j < nodes.length - 2; j += 2) {
            if (!nodes[j] || nodes[j+1] !== nodes[j+3])
                continue;
            nodes[j] += nodes[j + 2];
            nodes.splice(j+1, 2);
            j -= 2;
        }
        // sanityCheck(nodes);
        return removedTotal;
    }


    function apply(nodes, op, authPoolId) {
        authPoolId = authPoolId || 0;

        var index = 0;
        var opLen;
        for (var i = 0; i < op.length; i++) {
            opLen = operations.length(op[i]);
            switch (operations.type(op[i])) {
            case "retain":
                index += opLen;
                break;
            case "insert":
                insert(nodes, index, opLen, authPoolId);
                index += opLen;
                break;
            case "delete":
                remove(nodes, index, opLen);
                break;
            default:
                throw new TypeError("Unknown operation: " + operations.type(op[i]));
            }
        }
    }

    return {
        apply: apply,
        // insert: insert,
        // remove: remove
    };
}

var applyAuthorAttributes = AuthorAttributes().apply;

/**
 * Hash a string (document content) for easier comparison of state changes
 */
function hashString(str) {
    // if ((str + "").indexOf("\r") != -1) debugger
    return crypto.createHash('md5').update(str).digest("hex");
}

/**
 * Normalize document path to discard workspace prefix
 */
function getDocPath(path) {
    if (path.indexOf(basePath) === 0)
        return path.substring(basePath.length+1);
    return path;
}

var emitter = new events.EventEmitter();

/**
 * Document Store database wrapper utility to ease persistence/retrieval and update of entities such as:
 * Documents, Revisions, Workspace, ChatMessages, Users
 */
var Store = (function () {
    /**
     * Create a `Document` from a template with path, contents
     * Also, create its Revision#0 record
     * @param {Object}   tmpl
     * @param {Function} callback
     */
    function newDocument(tmpl, callback) {
        var contents = tmpl.contents || "";
        var fsHash = tmpl.fsHash || hashString(contents);
        wrapSeq(Document.create({
            contents: new Buffer(contents),
            path: tmpl.path,
            fsHash: fsHash,
            authAttribs: contents.length ? JSON.stringify([contents.length, null]) : "[]",
            starRevNums: "[]",
            newLineChar: tmpl.newLineChar || DEFAULT_NL_CHAR_DOC,
            revNum: 0
        }), function (err, doc) {
            if (err)
                return callback(err);
            wrapSeq(Revision.create({
                document_id: doc.id,
                operation: new Buffer("[]"),
                revNum: 0
            }), function (err, rev) {
                if (err)
                    return callback(err);
                doc.revisions = parseRevisions([rev]);
                callback(null, parseDocument(doc));
            });
        });
    }

    /*
    function moveDocument(docId, newPath, callback) {
        wrapSeq(Document.find(docId), function (err, doc) {
            if (err || !doc)
                return callback(err || "No document found to rename!");
            doc.path = newPath;
            wrapSeq(doc.save(), callback);
        });
    }
    */

    function parseDocument(doc) {
        if (doc.authAttribs)
            doc.authAttribs = JSON.parse(doc.authAttribs);
        if (doc.starRevNums)
            doc.starRevNums = JSON.parse(doc.starRevNums);
        doc.contents = doc.contents && doc.contents.toString(); // because it can be a buffer
        return doc;
    }

    function parseDocumentCallback(callback) {
        return function (err, doc) {
            if (err || !doc)
                return callback(err);

            callback(null, parseDocument(doc));
        };
    }

    /**
     * Get a `Document` from the database given its path
     * @param {String}   path the document path to query the database with
     * @param [{String}] attributes - optional
     * @param {Function} callback
     * @param {Object} callback.err
     * @param {Object} callback.result   The result, or null if getDocument() failed (might even though err is null)
     */
    function getDocument(path, attributes, callback) {
        var query = { where: {path: getDocPath(path)} };
        if (!callback) {
            callback = attributes;
            attributes = undefined;
        }
        else {
            attributes.unshift("id");
            query.attributes = attributes; // ["id", other attributes]
        }

        return wrapSeq(Document.find(query), parseDocumentCallback(callback));
    }

    /**
     * Get the revisions of a certain document
     * @param {Document} doc
     * @param {Function} callback
     */
    function getRevisions(doc, callback) {
        wrapSeq(doc.getRevisions(), function (err, revisions) {
            if (err)
                return callback(err);
            callback(null, parseRevisions(revisions));
        });
    }
    
    /**
     * In-place parsing of revisions
     * @param [{Revision}] revisions
     */
    function parseRevisions(revisions) {
        revisions.forEach(function (rev) {
            // rev.operation can be a buffer and is always a stringified JSON array
            rev.operation = JSON.parse(rev.operation.toString());
        });
        revisions.sort(function(a, b) {
            return a.revNum - b.revNum;
        });
        return revisions;
    }

    function prepareAttributes(doc, attributes) {
        var update = {};
        for (var i = 0; i < attributes.length; i++)
            update[attributes[i]] = doc[attributes[i]];
        return update;
    }

    /**
     * Save a document with changes to the database
     * @param {Function} callback
     */
    function saveDocument(doc, callback) {
        var authAttribs = doc.authAttribs;
        var starRevNums = doc.starRevNums;
        doc.authAttribs = JSON.stringify(authAttribs);
        doc.starRevNums = JSON.stringify(starRevNums);
        doc.contents = new Buffer(doc.contents);
        doc.updated_at = new Date();
        doc.lastUpdate = doc.updated_at.getTime();
        console.error("Saving document to db with lastUpdate: " + doc.lastUpdate);

        return wrapSeq(
            doc.save(),
            function(err) {
                doc.authAttribs = authAttribs;
                doc.starRevNums = starRevNums;
                callback(err, doc);
            }
        );
    }

    /**
     * Gets the latest workspace state with the most important properties being: aurhorPool and colorPool
     * @param {Function} callback
     */
    function getWorkspaceState(callback) {
        // the table has only a single entry
        if (cachedWS)
            return callback(null, cachedWS);
        wrapSeq(Workspace.find(1), function (err, ws) {
            if (err || !ws)
                return callback(err || "No workspace state found!");
            ws.authorPoolParsed = parseJSONField(ws.authorPool);
            ws.colorPoolParsed = parseJSONField(ws.colorPool);
            cachedWS = ws;
            callback(null, ws);
        });
    }

    /**
     * Save the workspace with changes to the database
     * @param {Workspace} ws
     * @param {Function}  callback
     */
    function saveWorkspaceState(ws, callback) {
        var authorPool = ws.authorPoolParsed;
        var colorPool = ws.colorPoolParsed;
        ws.authorPool = JSON.stringify(authorPool);
        ws.colorPool = JSON.stringify(colorPool);
        return wrapSeq(ws.save(), function(err, savedWS) {
            if (err) {
                cachedWS = null;
                return callback(err);
            }
            savedWS.authorPoolParsed = authorPool;
            savedWS.colorPoolParsed = colorPool;
            cachedWS = savedWS;
            callback(null, savedWS);
        });
    }

    /**
     * Save a document with changes to the database
     * @param {Function} callback
     */
    function getUsers(callback) {
        if (cachedUsers)
            return callback(null, cachedUsers);
        wrapSeq(User.all(), function (err, users) {
            cachedUsers = users;
            callback(err, users);
        });
    }

    /**
     * Add uer's chat message to the database
     * @param {String}   text
     * @param {String}   userId
     * @param {Function} callback
     */
    function saveChatMessage(text, userId, callback) {
        wrapSeq(ChatMessage.create({
            text: text,
            userId: userId
        }), callback);
    }

    /**
     * Get the most recent chat messages
     * @param {Number}   limit - optional
     * @param {Function} callback
     */
    function recentChatHistory(limit, callback) {
        limit = limit || 100;
        wrapSeq(ChatMessage.findAll({
            order: 'timestamp DESC',
            limit: limit
        }), function(err, history) {
            if (err)
                return callback(err);
            callback(null, history.reverse());
        });
    }

    return {
        newDocument: newDocument,
        // moveDocument: moveDocument, // not used
        getDocument: getDocument,
        getRevisions: getRevisions,
        saveDocument: saveDocument,
        getWorkspaceState: getWorkspaceState,
        saveWorkspaceState: saveWorkspaceState,
        getUsers: getUsers,
        saveChatMessage: saveChatMessage,
        recentChatHistory: recentChatHistory
    };
})();


// This object should have the following structure:
//
//     { <document id> : { <client id> : true } }
var documents = {};

// This object should have the following structure:
//
//     { <document id> : { fs.FSWatcher } }
var watchers;

// This object should have the following structure:
//
//     { <client id> : <client> }
var clients;

var lastSaveStarts = {};

// SQLite doesn't provide atomic instructions or locks
// So this variable expresses in-process locks
// Used to block concurrent edit updates while the document is being processed
//
//     { <key or document_id> : [{Function}] }
var locks = {};
function lock(key, callback) {
    if (!locks[key]) {
        locks[key] = [];
        return callback();
    }
    
    var watchdog = setTimeout(function() {
        throw Error("[vfs-collab] Lock timeout"); // log & suicide
    }, 60000);
    return locks[key].push(function() {
        clearTimeout(watchdog);
        callback();
    });
}

function unlock(key) {
    var lock = locks[key];
    if (!lock || !lock.length)
        return delete locks[key];
    var next = lock.shift();
    next();
}

// Selected using colors.html
var featuredColors = [
    {r: 255, g: 146, b: 45},
    {r: 157, g: 47, b: 254},
    {r: 105, g: 215, b: 83},
    {r: 255, g: 105, b: 130},
    {r: 200, g: 109, b: 218},
    {r: 210, g: 230, b: 51},
    {r: 6, g: 134, b: 255},
    {r: 254, g: 13, b: 244},
    {r: 188, g: 255, b: 86},
    {r: 255, g: 212, b: 125},
    {r: 107, g: 4, b: 255},
    {r: 66, g: 248, b: 255}
];

// An algorithm to select bright random colors
function randomColor() {
    var a,b,c;
    do {
      a = Math.random();
      b = Math.random();
      c = Math.max(a,b);
    } while (c < 0.001);

    // scale them such that the larger number scales to 1.0f
    var scale = 1.0 / c;
    a *= scale;
    b *= scale;

    // Pick third value, ensure it's dark.
    c = Math.random() * 0.5;
    var rgb = new Array(3);

    var idx = Math.floor(Math.random() * 3) % 3;
    rgb[idx] = a;

    var rnd2 = Math.floor(Math.random() * 2) + 1;
    var idx2 = (rnd2 + idx) % 3;
    rgb[idx2] = b;

    var idx3 = 3 - (idx + idx2);
    rgb[idx3] = c;

    rgb = rgb.map(function(x) {
        return Math.floor(255 * x);
    });
    return {r: rgb[0], g: rgb[1], b: rgb[2]};
}

/**
 * Handle new collab connections (can be reconnects)
 * Sync user's info to the collab database and select a color and aurhor id for him/her if not previously set
 * Send USER_JOIN notifications to other connected members
 * Send handshake CONNECT message to the user with the needed workspace info and chat history
 */
function handleConnect(userIds, client) {
    var userId = userIds.userId;
    var clientId = userIds.clientId;

    function done(err) {
        if (!err)
            return;
        console.error(err);
        client.send({
            type: "CONNECT",
            error: err
        });
    }

    // Make sure to cache user's info
    syncUserInfo();

    function syncUserInfo() {
        if (!userId)
            return done("[vfs-collab] Anonyous users connections not supported");

        var fullname = userIds.fullname;
        var email = userIds.email;
        
        wrapSeq(User.find({where: {uid: userId}}), function (err, user) {
            if (err)
                return done("[vfs-collab] syncUserInfo " + String(err));

            if (!user) {
                return wrapSeq(User.create({
                    uid: userId,
                    fullname: fullname,
                    email: email
                }), function(err, createdUser) {
                    if (err)
                        return done("[vfs-collab] Failed creating user " +  String(err));
                    cachedUsers && cachedUsers.push(createdUser);
                    augmentWorkspaceInfo();
                });
            }

            if (user.fullname == fullname && user.email == email)
                return augmentWorkspaceInfo();

            user.fullname = fullname;
            user.email = email;
            wrapSeq(user.save(), function (err, user) {
                if (err)
                    return done("[vfs-collab] Failed updating user " + String(err));
                augmentWorkspaceInfo();
            });
        });
    }

    function augmentWorkspaceInfo() {
        Store.getWorkspaceState(function (err, ws) {
            if (err)
                return done("[vfs-collab] augmentWorkspaceInfo " + String(err));
            var authorPool = ws.authorPoolParsed;
            var colorPool = ws.colorPoolParsed;

            if (authorPool[userId] && colorPool[userId])
                return doConnect(authorPool, colorPool);

            if (!authorPool[userId])
                authorPool[userId] = Object.keys(authorPool).length + 1;
            if (!colorPool[userId])
                colorPool[userId] = featuredColors[authorPool[userId]-1] || randomColor();
            Store.saveWorkspaceState(ws, function (err) {
                if (err)
                    return done("[vfs-collab] augmentWorkspaceInfo " + String(err));
                doConnect(authorPool, colorPool);
            });
        });
    }

    function doConnect(authorPool, colorPool) {
        Store.getUsers(function (err, users) {
            if (err)
                return done("[vfs-collab] getUsers " + String(err));

            if (users.length > 1)
                console.error("[vfs-collab] User", userIds.userId, "is connecting to a workspace with",
                    users.length - 1, "other workspace members");

            var onlineUsers = {};
            var idleUsers = {};
            for (var clId in clients) {
                var cl = clients[clId];
                var uid = cl.userIds.userId;
                if (!onlineUsers[uid])
                    onlineUsers[uid] = [];
                onlineUsers[uid].push(clId);
                var idleClinet = cl.state === "idle";
                if (typeof idleUsers[uid] === "undefined")
                    idleUsers[uid] = idleClinet; // set through a USER_STATE message
                else
                    idleUsers[uid] = idleUsers[uid] && idleClinet;
            }

            if (Object.keys(onlineUsers).length > 1)
                console.error("[vfs-collab] User", userIds.userId, "is connecting Collab with",
                    Object.keys(clients).length-1, "other clients & online workspace members", onlineUsers);

            var usersMap = {};
            users.forEach(function (user) {
                var uid = user.uid;
                var onlineUserClients = onlineUsers[uid] || [];
                var onlineState;
                if (idleUsers[uid])
                    onlineState = "idle";
                else if (onlineUserClients.length)
                    onlineState = "online";
                else
                    onlineState = "offline";
                usersMap[uid] = {
                    email: user.email,
                    fullname: user.fullname,
                    uid: user.uid,
                    clients: onlineUserClients, 
                    online: onlineUserClients.length,
                    state: onlineState,
                    author: authorPool[uid],
                    color: colorPool[uid]
                };
            });

            broadcast({
                type: "USER_JOIN",
                data: {
                    userId: userId,
                    clientId: clientId,
                    user: usersMap[userId]
                }
            }, client);

            Store.recentChatHistory(100, function (err, chatHistory) {
                if (err)
                    console.error("[vfs-collab] recentChatHistory", err);

                client.send({
                    type: "CONNECT",
                    data: {
                        myClientId: clientId,
                        myUserId: userId,
                        fs: userIds.fs,
                        authorPool: authorPool,
                        colorPool: colorPool,
                        users: usersMap,
                        chatHistory: chatHistory || []
                    }
                });
            });
        });
    }
}

/**
 * Returns true if the users has read access to the filesystem
 */
function collabReadAccess(fs) {
    return (/r/).test(fs);
}

/**
 * Returns true if the users has write access to the filesystem
 */
function collabWriteAccess(fs) {
    return (/w/).test(fs);
}

/**
 * Apply a user's operation to a document
 * @param {Object}    userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {String}    docId   - the document path
 * @param {Document}  doc     - the document to apply the operation on
 * @param {Operation} op      - the operation to applly
 * @param {Function}  callback
 */
function applyOperation(userIds, docId, doc, op, callback) {
    userIds = userIds || {userId: 0};
    var userId = userIds.userId;
    Store.getWorkspaceState(function (err, ws) {
        if (err)
            return callback(err);
        try {
            doc.contents = applyContents(op, doc.contents);
            applyAuthorAttributes(doc.authAttribs, op, ws.authorPoolParsed[userId]);

            wrapSeq(Revision.create({
                operation: new Buffer(JSON.stringify(op)),
                author: userId,
                revNum: doc.revNum + 1,
                document_id: doc.id
            }), next);
        } catch (e) {
            return next(e);
        }
    });
    function next(err) {
        if (err)
            return callback(err);
        if (userId == 0) {
            detectCodeRevertError(op, doc.revNum, doc);
        }
        var contentsHash = hashString(doc.contents);
        doc.revNum++;
        console.error("[vfs-collab] applyOperation saveDocument User " + userId + " client " + userIds.clientId + " doc " + docId + " revNum " + doc.revNum + " fsHash " + doc.fsHash + " contentsHash " + contentsHash + " time: " + Date.now());
        Store.saveDocument(doc, function (err) {
            if (err)
                return callback(err);
                
            console.error("[vfs-collab] applyOperation successfully saved User " + userId + " client " + userIds.clientId + " doc " + docId + " revNum " + doc.revNum + " fsHash " + doc.fsHash + " contentsHash " + contentsHash + " time: " + Date.now());
            var msg = {
                docId: docId,
                clientId: userIds.clientId,
                userId: userId,
                revNum: doc.revNum,
                op: op
            };
            callback(null, msg);
        });
    }
}

function detectCodeRevertError(operation, lastRevisionNum, doc) {
    Store.getRevisions(doc, function(err, revisions) {
        if (err) return console.error("[vfs-collab] Failed to get document revisions in detectCodeRevertError");
        
        var lastRevision = revisions[lastRevisionNum];
        if (!lastRevision || !lastRevision.operation) return;
        
        
        var lastOperation = lastRevision.operation;
        if (operation.length != lastOperation.length) return;
        
        if (!areOperationsMirrored(operation, lastOperation)) return;
        
        console.error("[vfs-collab] ERROR: Detected code revert by system in ", doc.path, "revision " + (lastRevisionNum + 1) + ". Investigation needed.");
    });
}

// Check if all operations are the same except for insert/delete which is the opposite
function areOperationsMirrored(operation1, operation2) {
    if (!operation1.length || !operation2.length) return false;
    operation1 = removeNoopOperations(operation1);
    operation2 = removeNoopOperations(operation2);
    
    function areOpsMirrors(op1, op2) {
        if (!op1.length || !op2.length) return true;
        if (["i", "d"].indexOf(op1.charAt(0)) >=0 && ["i", "d"].indexOf(op2.charAt(0)) >= 0) {
            if (op1.charAt(0) != op2.charAt(0) && op1.slice(1) == op2.slice(1)) {
                return true; 
            }
        } 
        else if (op1 == op2) {
            return true;
        }
    }
    
    for (var i = 0; i < operation1.length; i++) {
        if (areOpsMirrors(operation1[i], operation2[i])) continue; 
        
        // Check if they are mirrored and order is just flipped
        if (operation2[i+1] != null && areOpsMirrors(operation1[i], operation2[i+1]) && areOpsMirrors(operation1[i+1], operation2[i])) {
            i++; // As we already compared this and the next
            continue;
        }
        
        return false;
    }
    
    return true;
}

function removeNoopOperations(ops) {
    var operations = ops.filter(function (op) {
        if (["d", "i", "r0"].indexOf(op) >= 0) { 
            return false;
        }
        return true;
    });
    
    return operations;
}

/**
 * Handle user's EDIT_UPDATE for a document
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the EDIT_UPDATE message data with the document id, revision number and applied operation
 */
function handleEditUpdate(userIds, client, data) {
    var docId = data.docId;
    var userId = userIds.userId;
    var clientId = userIds.clientId;
    var newRev = data.revNum;
    var docL;

    console.error("[vfs-collab] handleEditUpdate User " + userId + " client " + clientId + " doc " + docId + " revision " + newRev);
    function done(err) {
        unlock(docId);
        if (err) {
            syncCommit(err);
        }
    }

    // the user's edit couldn't be commited, please try again
    function syncCommit(err) {
        console.error("[vfs-collab] encountered syncCommit error User " + userId + " client " + clientId + " doc " + docId + " revision " + newRev + " err " + err.message);
        client.send({
            type: "SYNC_COMMIT",
            data: {
                docId: docId,
                revNum: docL && docL.revNum,
                reason: err.message || err,
                code: err.code || "SYNC_E"
            }
        });
    }

    if (!documents[docId] || !documents[docId][clientId] || !client.openDocIds[docId])
        return done("Trying to update a non-member document!",
            docId, clientId, documents[docId] && Object.keys(documents[docId]), Object.keys(client.openDocIds),
            Object.keys(documents), Object.keys(clients));

    if (!collabWriteAccess(userIds.fs))
        return done("User " + userIds.userId + " doesn't have write access to edit document " + docId + " - fs: " + userIds.fs);

    // Lock a document while updating - to stop any possible inconsistencies
    lock(docId, function () {
        Store.getDocument(docId, function (err, doc) {
            if (err || !doc)
                return done(err || ("No Document to update! " + docId));

            docL = doc;

            if (doc.revNum !== newRev-1) { // conflicting versions
                var err2 = new Error("Version log: " + docId + " "  + doc.revNum + " " + newRev);
                err2.code = "VERSION_E";
                return done(err2);
            }

            // message.author for udno auth attributes
            applyOperation(userIds, docId, doc, data.op, function (err, msg) {
                if (err) {
                    var err2 = new Error("OT Error: " + String(err));
                    err2.code = "OT_E";
                    return done(err2);
                }

                msg.selection = data.selection;
                var contentsHash = hashString(doc.contents);
                console.error("[vfs-collab] broadcasting EDIT_UPDATE User " + userId + " client " + clientId + " doc " + docId + " revision " + newRev + " fsHash " + doc.fsHash + " contentsHash " + contentsHash);
                broadcast({
                    type: "EDIT_UPDATE",
                    data: msg
                }, client, docId);

                delete msg.op;
                delete msg.selection;

                client.send({
                    type: "EDIT_UPDATE",
                    data: msg
                });
                
                emitter.emit("afterEditUpdate", {
                    docId: docId,
                    path: getAbsolutePath(docId),
                    doc: doc
                });

                done();
            });
        });
    });
}

function handleResolveConflict(userInfo, client, data) {
    var docId = data.docId;
    console.error("[vfs-collab] Handling resolve conflict with data: ", data, " doc is: ", documents[docId]);
    broadcast({
        type: "RESOLVE_CONFLICT",
        data: data
    }, client, docId); 
}

/**
 * Handle user's UPDATE_NL_CHAR for a document
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the UPDATE_NL_CHAR message data with the document id, newLineChar
 */
function handleUpdateNlChar(userInfo, client, data) {
    var docId = data.docId;
    var newLineChar = data.newLineChar || "";

     var nlCharLog;
    switch (newLineChar) {
        case "\n":
            nlCharLog = "\\n";
            break;
        case "\r\n":
            nlCharLog = "\\r\\n";
            break;
        default:
            nlCharLog = newLineChar.length + ":" + newLineChar;
            return missingInfo();
    }

    if (!docId)
        return missingInfo();

    function missingInfo() {
        console.error("[vfs-collab] updateNlChar missing info:", docId, nlCharLog);
    }

    function done(err) {
        unlock(docId);
        if (err)
            console.error("[vfs-collab] updateNlChar failed:", err);
    }

    // Lock a document while updating - to stop any possible inconsistencies
    lock(docId, function () {
        Store.getDocument(docId, function(err, doc) {
            if (err || !doc)
                return done((err || "updateNlChar of a non-collab document!") + " : " +  docId);
            if (doc.newLineChar == newLineChar)
                return done();
            doc.newLineChar = newLineChar;
            Store.saveDocument(doc, function (err) {
                if (err)
                    return done(err);
                console.error("[vfs-collab] updateNlChar changed", newLineChar);

                broadcast({
                    type: "UPDATE_NL_CHAR",
                    data: {
                        docId: docId,
                        newLineChar: newLineChar
                    }
                }, client, docId);
                done();
            });
        });
    });
}

/**
 * Handle user's CHAT_MESSAGE
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the CHAT_MESSAGE data with the chat text
 */
function handleChatMessage(userIds, client, data) {
    var text = data.text;
    var userId = userIds.userId;

    // Save the chat message and broadcast it
    Store.saveChatMessage(text, userId, function (err, message) {
      if (err)
          return console.error("[vfs-collab] saveChatMessage:", err);
      var msg = {
          type: "CHAT_MESSAGE",
          data: {
            id: message.id,
            userId: userId,
            timestamp: message.timestamp,
            text: text
          }
      };

      broadcast(msg);
  });
}

/**
 * Handle user's CURSOR_UPDATE messages
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the CURSOR_UPDATE data with the document id and the user selection
 */
function handleCursorUpdate(userIds, client, data) {
    var docId = data.docId;
    var clientId = userIds.clientId;

    if (!documents[docId] || !documents[docId][clientId] || !client.openDocIds[docId])
        return console.error("[vfs-collab] Trying to select in a non-member document!",
            docId, clientId, documents[docId] && Object.keys(documents[docId]), Object.keys(client.openDocIds),
            Object.keys(documents), Object.keys(clients));

    documents[docId][clientId].selection = data.selection;
    data.clientId = clientId;
    data.userId = userIds.userId;
    broadcast({
        type: "CURSOR_UPDATE",
        data: data
    }, client, docId);
}

/**
 * Broadcast a message to all or a selected group of connected collab clients
 * @param {Object} message - the message to broadcast
 * @param {Socket} sender  - optional, when we want to exclude the sender from the group to send the message to
 * @param {String} docId   - the document id or path
 */
function broadcast(message, sender, docId) {
    var toClientIds = docId ? documents[docId] : clients;
    var audienceNum = 0;
    for (var clientId in toClientIds) {
        var client = clients[clientId];
        // Exclude sender if exists
        if (client === sender || !client)
            continue;
        client.send(message);
        audienceNum++;
    }
    // if (audienceNum)
    //    console.error("[vfs-collab] Broadcast to:", audienceNum, "clients", message);
}

function getAbsolutePath(docId) {
    if (docId[0] === "~" && docId[1] === "/")
        return Path.join(getHomeDir(), docId.substring(1));
    else
        return Path.join(basePath, docId);
}

/**
 * Watch documents for other filesystem changes and sync them back to the collab documents
 * @param docId - the document id or path
 */
function initVfsWatcher(docId) {
    var absPath = getAbsolutePath(docId);

    function done(err) {
        if (err)
            console.error("[vfs-collab] WATCH ERR:", docId, err);
        unlock(docId);
    }

    // Check if a collab document sync is needed, apply it and save to the filesystem
    function doWatcherSync(stats, next) {
        var ctime = new Date(stats.ctime).getTime();
        var watcher = watchers[docId];
        var timeDiff = ctime - watcher.ctime;
        console.error("[vfs-collab] WATCH CHANGE:", docId, "last ctime:", watcher.ctime, "new ctime:", ctime);
        if (watcher.ctime && timeDiff < 1)
            return;
        lock(docId, function () {
            console.error("[vfs-collab] WATCH SYNC:", docId, "time diff: ", timeDiff);
            watcher.ctime = ctime;
            Store.getDocument(docId, function (err, oldDoc) {
                if (err)
                    return next(err);
                syncDocument(docId, oldDoc, null, false, function (err, doc2) {
                    if (err) return next(err);
                    if (doc2.syncedWithDisk) {
                        doSaveDocument(docId, doc2, -1, true, next);
                        delete doc2.syncedWithDisk;
                    }
                    next();
                });
            });
        });
    }

    localfsAPI.watch(absPath, {}, function (err, meta) {
        if (err)
            return console.error("[vfs-collab] WATCH INIT ERR:", docId, err);

        var watcher = meta.watcher;
        watcher.on("change", function (event, filename, stat, files) {
            doWatcherSync(stat, done);
        });
        watcher.on("error", function(err){
            console.error("[vfs-collab] WATCH ERR:", docId, err);
        });
        watchers[docId] = watcher;
        watcher.ctime = Date.now();
        Fs.stat(absPath, function (err, stat) {
            if (err) return;
            watcher.ctime = new Date(stat.ctime).getTime();
        });
    });
}

/**
 * Handle user's JOIN_DOC messages - a user is joining a document to collaborate on
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the JOIN_DOC data with the document id
 */
function handleJoinDocument(userIds, client, data) {
    var docId = data.docId;
    var clientId = userIds.clientId;
    var userId = userIds.userId;
    
    console.error("[vfs-collab] User", clientId, "trying to join document", docId);

    function done(err) {
        if (err) {
            console.error("[vfs-collab] handleJoinDocument ERR:", docId, err);
            client.send({
                type: "JOIN_DOC",
                data: {
                    clientId: clientId,
                    docId: docId,
                    err: err
                }
            });
        }
        console.error("[vfs-collab] User", clientId, "joined document", docId);
        unlock(docId);
    }

    lock(docId, function() {
        Store.getDocument(docId, function(err, doc) {
            if (err)
                return done("getDocument " + String(err));

            if (doc && documents[docId])
                return fetchMetadataThenJoinDocument(doc);

            console.error("[vfs-collab] Joining a closed document", docId, " - Syncing");
            syncDocument(docId, doc, client, false, function(err, doc2) {
                if (err)
                    return done(err);
                fetchMetadataThenJoinDocument(doc2);
            });
        });
    });

    function fetchMetadataThenJoinDocument(doc) {
        localfsAPI.getMetadata(docId, { sandbox: basePath }, function(err, metadata) {
            if (err)
                console.error("[vfs-collab] Warning: failed to fetch metadata!", docId, err);
            var file = getAbsolutePath(docId);
            isVeryLargeFile(file, doc.contents, function(err, isLarge) {
                if (err)
                    console.error("[vfs-collab] isVeryLargeFile failed:", err);
                if (!isLarge)
                    return joinDocument(doc, String(metadata || ""));
                client.send({
                    type: "LARGE_DOC",
                    data: {
                        userId: userId,
                        clientId: clientId,
                        docId: docId,
                        response: true
                    }
                });
            });
        });
    }

    function joinDocument(doc, metadata) {
        if (!documents[docId]) {
            documents[docId] = {};
            initVfsWatcher(docId);
            console.error("[vfs-collab] User", clientId, "is joining document", docId);
        }
        else {
            console.error("[vfs-collab] User", clientId, "is joining a document", docId, "with",
                Object.keys(documents[docId]).length, "other document members");
        }

        var docHash = hashString(doc.contents);

        var clientDoc = JSON.stringify({
            selections: documents[docId],
            authAttribs: doc.authAttribs,
            contents: doc.contents.toString(),
            metadata: metadata,
            fsHash: doc.fsHash,
            docHash: docHash,
            revNum: doc.revNum,
            newLineChar: doc.newLineChar,
            created_at: doc.created_at,
            updated_at: doc.updated_at,
            lastUpdate: doc.lastUpdate
        });

        documents[docId][clientId] = userIds;
        client.openDocIds[docId] = true;
        
        console.error("[vfs-collab] User", clientId, "is opening", docId, "revNum", doc.revNum, "docHash", docHash, "fsHash", doc.fsHash);

        // Cut the document to pices and stream to the client
        var chunkSize = 10*1024; // 10 KB
        var contentsLen = clientDoc.length;
        var chunksLen = Math.ceil(contentsLen / chunkSize);
        for (var i = 0; i < contentsLen; i += chunkSize) {
            var chunk = clientDoc.slice(i, i + chunkSize);
            client.send({
                type: "JOIN_DOC",
                data: {
                    userId: userId,
                    clientId: clientId,
                    docId: docId,
                    reqId: data.reqId,
                    chunkNum: (i / chunkSize) + 1,
                    chunksLength: chunksLen,
                    chunk: chunk
                }
            });
        }
        
        if (doc.hasPendingChanges) {
            console.error("Sending doc ", docId, " has pending changes to user ", userId, " client ", clientId);
            client.send({
                type: "DOC_HAS_PENDING_CHANGES",
                data: {
                    userId: userId,
                    clientId: clientId,
                    docId: docId,
                }
            });
            delete doc.hasPendingChanges;
        }

        if (doc.changedOnDisk) {
            console.error("Sending doc ", docId, " has changed on disk to user ", userId, " client ", clientId);
            client.send({
                type: "DOC_CHANGED_ON_DISK",
                data: {
                    userId: userId,
                    clientId: clientId,
                    docId: docId,
                }
            });
            delete doc.changedOnDisk;
        }

        broadcast({
            type: "JOIN_DOC",
            data: {
                docId: docId,
                userId: userId,
                clientId: clientId
            }
        }, client);

        done();
    }
}

/**
 * Normalize text line terminators for collab index-based calculations to seamlessly work
 * @param  {String} text
 * @return {String} normalized
 */
function normalizeTextLT(text) {
    return text.replace(/\r\n|\r/g, "\n");
}

// return "\n" or "\r\n" or null
function detectNewLineChar(text) {
    // Must be the strictly same as on the client
    // (and note that Ace doesn't have \r newLine mode)
    var match = text.match(/^.*?(\r\n|\n)/m);
    return match && match[1];
}

/**
 * Synchronize collab document state with the filesystem state (utilizing hashes)
 *
 * @param {String}   docId - the document id or path
 * @param {Document} doc   - the collab document
 * @param {Client} client   - the client requesting the sync
 * @param {Boolean} forceSync   - skip all the sanity checks, just sync from disk if the collab doc is different from disk
 * @param {Function} callback
 */
function syncDocument(docId, doc, client, forceSync, callback) {
    var file = getAbsolutePath(docId);
    isBinaryFile(file, function (err, isBinary) {
        if (err)
            return callback(new Error("SYNC: Binary check failed - ERR: " + String(err)));
        if (isBinary)
            return callback(new Error("SYNC: Binary file opened " + isBinary));
        
        isVeryLargeFile(file, null, function(err, isLarge) {
            if (err)
                return callback(err);

            if (!isLarge)
                return doSyncDocument();
            
            console.error("[vfs-collab] File is too large, ignoring: " + file);
            err = new Error("File is too large");
            err.code = "ELARGE";
            callback(err);
        });
    });
    
    function doSyncDocument() {
        Fs.readFile(file, "utf8", function (err, contents) {
            if (err)
                return callback(err);

            // "\n" or "\r\n" or null
            var newLineChar = detectNewLineChar(contents);
            var oldNewLineChar = doc && doc.newLineChar || DEFAULT_NL_CHAR_DOC;
            var normContents = normalizeTextLT(contents);

            var fsHash = hashString(normContents);
            
            // HACK: fsHash from database is unreliable (https://github.com/c9/newclient/issues/3980)
            if (doc)
                doc.fsHash = hashString(doc.contents);

            if (!doc) {
                console.error("[vfs-collab] SYNC: Creating document:", docId, fsHash);

                Store.newDocument({
                    path: docId,
                    contents: normContents,
                    fsHash: fsHash,
                    newLineChar: newLineChar
                }, callback);
            }
            // update database OT state
            else if (fsHash !== doc.fsHash && doc.contents != normContents) {
                console.error("[vfs-collab] Doc", docId, " revnum: ", doc.revNum ,"with hash:", doc.fsHash, "does not match file system hash", fsHash);
                if (forceSync) return syncCollabDocumentWithDisk();
                
                // Check if the document was updated at the same time as this revision. 
                // If it was then this doc has been saved as a revision before, no need to sync to it
                Fs.stat(file, function (err, stats) {
                    if (err) return callback(err);
                    
                    var lastFileChange = stats.ctime.getTime();
                    var lastCollabChange = doc.lastUpdate;
                    var lastSaveStart = lastSaveStarts[docId];
                    console.error("[vfs-collab] Doc", docId, "Last file change:", lastFileChange, " last collab change:", lastCollabChange, " last save start: ", lastSaveStart);
                    
                    // Never sync if the last doc change is older than the last collab change
                    if (lastFileChange < lastCollabChange) {
                        if (!client) {
                            console.error("[vfs-collab] Broadcasting document", docId, "has pending changes");
                            broadcast({
                                type: "DOC_HAS_PENDING_CHANGES",
                                data: {
                                    docId: docId
                                }
                            });
                        } 
                        else {
                            doc.hasPendingChanges = true;
                        }
                        return callback(null, doc);
                    }
                    
                    return documentContentsHaveChanged(lastCollabChange);
                });
            }
            else {
                checkNewLineChar();
                callback(null, doc);
            }
            
            function documentContentsHaveChanged(lastCollabChange) {
                var timeSinceLastCollabChange = Date.now() - lastCollabChange;
                if (wasLatestRevisionSaved(doc)) {
                    return syncCollabDocumentWithDisk();
                } else if (timeSinceLastCollabChange > UNSAVED_CHANGE_EXPIRY_TIME) {
                    console.error("[vfs-collab] Doc ", docId, " last collab change was " + (timeSinceLastCollabChange / 1000) + "s ago. Expiring change and syncing from disk");
                    return syncCollabDocumentWithDisk();
                }
                
                return informUserFileContentsHaveChanged();
            }
            
            function informUserFileContentsHaveChanged() {
                if (!client) {
                    console.error("[vfs-collab] Broadcasting document", docId, "contents have changed");
                    broadcast({
                        type: "DOC_CHANGED_ON_DISK",
                        data: {
                            docId: docId
                        }
                    });
                } else {
                    doc.changedOnDisk = true;
                }
                return callback(null, doc);
            }
            
            function syncCollabDocumentWithDisk() {
                var op = operations.operation(doc.contents, normContents);
                console.error("[vfs-collab] SYNC: Syncing document from disk:", docId, op.length, "fsHash", fsHash, "docHash", doc.fsHash);
                // non-user sync operation
                doc.fsHash = fsHash; // applyOperation will save it for me
                
                doc.syncedWithDisk = true;
                doc.newLineChar = newLineChar || oldNewLineChar;
                applyOperation(null, docId, doc, op, function (err, msg) {
                    if (err)
                        return callback("SYNC: Failed updating OT database document state! " + String(err));
                    msg.sync = true;
                    broadcast({
                        type: "EDIT_UPDATE",
                        data: msg
                    }, null, docId);

                    checkNewLineChar();
                    callback(null, doc);
                });
            }

            function checkNewLineChar() {
                if (newLineChar && oldNewLineChar !== newLineChar) {
                    broadcast({
                        type: "UPDATE_NL_CHAR",
                        data: {
                            oldNewLineChar: oldNewLineChar,
                            newLineChar: newLineChar
                        }
                    }, null, docId);
                    doc.newLineChar = newLineChar || oldNewLineChar;
                }
            }
        });
    }
}

/**
 * Handle user's GET_REVISIONS messages - retrive the revision history of the file
 *
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the JOIN_DOC data with the document id
 */
function handleGetRevisions(userIds, client, data) {
    var docId = data.docId;

    function done(err) {
        if (err)
            console.error("[vfs-collab] handleGetRevisions ERR:", docId, err);
        unlock(docId);
    }

    lock(docId, function () {
        Store.getDocument(docId, function (err, doc) {
            if (err)
                return done("getDocument " + String(err));

            Store.getRevisions(doc, function (err, revisions) {
                if (err || !revisions)
                    return done("getRevisions " + (revisions || []).length + " " + String(err));

                var docRevisions = JSON.stringify({
                    revisions: revisions,
                    starRevNums: doc.starRevNums,
                    revNum: doc.revNum
                });

                // Cut the revisions into pices and stream to the client
                var chunkSize = 10*1024; // 10 KB
                var contentsLen = docRevisions.length;
                var chunksLen = Math.ceil(contentsLen / chunkSize);
                for (var i = 0; i < contentsLen; i += chunkSize) {
                    var chunk = docRevisions.slice(i, i + chunkSize);
                    client.send({
                        type: "GET_REVISIONS",
                        data: {
                            userId: userIds.userId,
                            clientId: userIds.clientId,
                            docId: data.docId,
                            chunkNum: (i / chunkSize) + 1,
                            chunksLength: chunksLen,
                            chunk: chunk
                        }
                    });
                }
                done();
            });
        });
    });
}

/**
 * Handle user's SAVE_FILE messages - save collab documents
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the SAVE_FILE data with the document id and wether to sielently save (with auto-save enabled) or star the save
 */
function handleSaveFile(userIds, client, data) {
    var st = Date.now();
    var docId = data.docId;
    var userId = userIds.userId;
    
    lastSaveStarts[docId] = Date.now();

    function done(err) {
        unlock(docId);
        if (err) {
            console.error("[vfs-collab] Failed to save file. docID: " + docId + " Err: ", err);
            client.send({
                type: "FILE_SAVED",
                data: {
                    docId: docId,
                    err: err
                }
            });
        }
    }

    console.error("[vfs-collab] Saving file", docId);
    client.send({type: "FILE_LOCKING", data: {docId: docId}});

    lock(docId, function () {
        client.send({type: "FILE_LOCKED", data: {docId: docId}});
        Store.getDocument(docId, ["contents", "revNum", "starRevNums", "newLineChar"], function (err, doc) {
            if (err || !doc)
                return done((err || "Writing a non-collab document!") + " : " +  docId);

            if (watchers[docId])
                watchers[docId].ctime = Date.now();
                
            client.send({type: "FILE_RETRIEVED", data: {docId: docId}});

            var absPath = getAbsolutePath(docId);
            var fileContents = doc.contents.replace(/\n/g, doc.newLineChar || DEFAULT_NL_CHAR_FILE);

            function mkfileWriteFile() {
                var options = { bufferWrite: true };
                var stream = options.stream = new Stream();
                stream.readable = true;
                localfsAPI.mkfile(absPath, options, writeFileCallback);
                stream.emit("data", fileContents);
                stream.emit("end");
            }

            /*
            function regularWriteFile() {
                Fs.writeFile(absPath, doc.contents, "utf8", writeFileCallback);
            }
            */

            function writeFileCallback(err) {
                if (err) return done("Failed saving file ! : " + docId  + " ERR: " + String(err));
                
                client.send({type: "DATA_WRITTEN", data: {docId: docId}});
                doSaveDocument(docId, doc, userId, !data.silent, function (err) {
                    console.error("[vfs-collab] Saving took", Date.now() - st, "ms - time is now: " + Date.now() + " file:", docId, !err);
                    done(err);
                });
            }

            mkfileWriteFile();
        });
    });
}

/**
 * Apply the save to the collab document, update the hash and optionally add a star revision
 * @param {String}   docId     - the document id or path
 * @param {Document} doc       - the collab document
 * @param {String}  userId     - the user id
 * @param {Boolean} star       - add a star to the document if not triggered by auto-save
 * @param {Function} callback
 */
function doSaveDocument(docId, doc, userId, star, callback) {
    if (star && doc.starRevNums.indexOf(doc.revNum) === -1)
        doc.starRevNums.push(doc.revNum);

    var fsHash = doc.fsHash = hashString(doc.contents);
    Store.saveDocument(doc, function (err) {
        if (err)
            return callback(err);
        console.error("[vfs-collab] User", userId, "saved document", docId, "revision",  doc.revNum, "hash", fsHash);
        var data = {
            userId: userId,
            docId: docId,
            star: star,
            revNum: doc.revNum,
            fsHash: fsHash
        };
        broadcast({
            type: "FILE_SAVED",
            data: data
        }, null, docId);
        callback();
    });
}

/** 
 * Was the latest document revision saved to disk or is it just in the collabdb
 * @param {Document} doc
 */
function wasLatestRevisionSaved(doc) {
    return doc.starRevNums && doc.starRevNums.indexOf(doc.revNum) >= 0;
}


/**
 * Handle user's LEAVE_DOC messages - client closing a collab document
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the LEAVE_DOC data with the document id
 */
function handleLeaveDocument(userIds, client, data) {
    var docId = data.docId;
    var userId = userIds.userId;
    var clientId = userIds.clientId;
    var userDisconnected = data.disconnected;
    if (!documents[docId] || !documents[docId][clientId] || !client.openDocIds[docId])
        return console.error("[vfs-collab] Trying to leave a non-member document!",
            docId, clientId, documents[docId] && Object.keys(documents[docId]), Object.keys(client.openDocIds),
            Object.keys(documents), Object.keys(clients));
    delete client.openDocIds[docId];
    console.error("[vfs-collab]", clientId, "is leaving document", docId);
    delete documents[docId][clientId];
    if (!Object.keys(documents[docId]).length) {
        console.error("[vfs-collab] Closing document", docId);
        if (!userDisconnected) {
            // If the user closed this on purpose and it's the last user
            // Resync this document with what's on disk to remove unsaved collab changes
            console.error("[vfs-collab] Last user closed document ", docId, " resyncing it from disk");
            Store.getDocument(docId, function (err, doc) {
                if (err) return console.error("[vfs-collab] Failed to get doc", docId, " from the store. Error is: ", err.message);
                syncDocument(docId, doc, null, true, function(err) {
                    if (err) return console.error("[vfs-collab] Failed to sync", docId, "with disk. Error is: ", err.message);
                    console.error("[vfs-collab] Successfully synced document", docId, " with disk.");
                });
            });
        }
        closeDocument(docId);
    }

    broadcast({
        type: "LEAVE_DOC",
        data: {
            docId: docId,
            userId: userId,
            clientId: clientId
        }
    }, client);
}

/**
 * Handle user's LARGE_DOC messages - document has grown too large for collab
 * 
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the LEAVE_DOC data with the document id
 */
function handleLargeDocument(userIds, client, data) {
    var docId = data.docId;
    var userId = userIds.userId;
    var clientId = userIds.clientId;
    console.error("[vfs-collab] ", docId);
    delete documents[docId][clientId];
    if (!Object.keys(documents[docId]).length) {
        console.error("[vfs-collab] File has grown too large, ignoring: " + docId);
        closeDocument(docId);
    }

    broadcast({
        type: "LARGE_DOC",
        data: {
            docId: docId,
            userId: userId,
            clientId: clientId
        }
    }, client);
}

/**
 * Handle user's USER_STATE messages - update connected clients with user state
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the JOIN_DOC data with the document id
 */
function handleUserState(userIds, client, data) {
    var userId = userIds.userId;
    var clientId = userIds.clientId;
    console.error("[vfs-collab]", clientId, "is switching to", data.state);
    clients[clientId].state = data.state;
    var isUserIdle = Object.keys(clients)
        .map(function(cliId) {
            return clients[cliId];
        }).filter(function(cl) {
            return cl.userIds.userId === userId;
        }).reduce(function(isIdle, cl) {
            return isIdle && cl.state === "idle";
        }, true);

    broadcast({
        type: "USER_STATE",
        data: {
            state: isUserIdle ? "idle" : "online",
            userId: userId,
            clientId: clientId
        }
    }, client);
}

/**
 * Clears specific chat messages or complete chat history
 *
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - either id: $id of the message to be deleted or clear: true to clear all of the chat history
 */
function handleClearChat(userIds, client, data) {
    console.error("[vfs-collab] Clear chat history: ", data.id, data.clear, userIds.fs);

    if (!collabWriteAccess(userIds.fs))
        return console.error("[vfs-collab] clearChat: User don't have write access!");

    var stmt;
    if (data.clear)
        stmt = ChatMessage.destroy({}, {truncate: true});
    else if (data.id)
        stmt = ChatMessage.destroy({id: data.id});
    else
        return console.error("[vfs-collab] clearChat: Invalid message", data);

    wrapSeq(stmt, function(err) {
        console.error("[vfs-collab] Chat clear:", err ? err : "SUCCESS");
        if (err)
            return;
        broadcast({
            type: "CLEAR_CHAT",
            data: data
        });
    });
}

/**
 * Clears specific chat messages or complete chat history
 *
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - either id: $id of the message to be deleted or clear: true to clear all of the chat history
 */
function broadcastUserMessage(userIds, client, data) {
    console.error("[vfs-collab] Clear chat history: ", data.id, data.clear, userIds.fs);

    broadcast({
        type: "MESSAGE",
        data: data
    }, client);
}


function isPathAllowed(userIds, docId) {
    // only accept normalized unix paths without /../ or /./ or ../
    if (/(\/|^)[.]{1,2}(\/|$)|\\/.test(docId))
        return false;
    // do not allow redonly users to open ~
    if (userIds.fs == "r" && docId[0] === "~" && docId[1] === "/")
        return false;
    return true;
}

/**
 * Handle any user message by routing to its proper handler
 *
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the connected collab client
 * @param {Object} data    - the SAVE_FILE data with the document id and wether to sielently save (with auto-save enabled) or star the save
 */
function handleUserMessage(userIds, client, message) {
    var data = message.data || {};
    var docId = data.docId || "";
    if (docId[0] === "/")
        docId = docId.slice(1);
    
    if (!isPathAllowed(userIds, docId)) {
        return client.send({
            type: message.type,
            data: {
                clientId: userIds.clientId,
                docId: docId,
                err: {message: "Not allowed."}
            }
        });
    }
    data.docId = docId;
    switch (message.type) {
    case "JOIN_DOC":
        handleJoinDocument(userIds, client, data);
        break;
    case "GET_REVISIONS":
        handleGetRevisions(userIds, client, data);
        break;
    case "LEAVE_DOC":
        handleLeaveDocument(userIds, client, data);
        break;
    case "LARGE_DOC":
        handleLargeDocument(userIds, client, data);
        break;
    case "EDIT_UPDATE":
        handleEditUpdate(userIds, client, data);
        break;
    case "RESOLVE_CONFLICT":
        handleResolveConflict(userIds, client, data);
        break;
    case "UPDATE_NL_CHAR":
        handleUpdateNlChar(userIds, client, data);
        break;
    case "CURSOR_UPDATE":
        handleCursorUpdate(userIds, client, data);
        break;
    case "SAVE_FILE":
        handleSaveFile(userIds, client, data);
        break;
    case "CHAT_MESSAGE":
        handleChatMessage(userIds, client, data);
        break;
    case "USER_STATE":
        handleUserState(userIds, client, data);
        break;
    case "CLEAR_CHAT":
        handleClearChat(userIds, client, data);
        break;
    case "PING":
        client.send({type: "PING"});
        break;
    case "MESSAGE":
        broadcastUserMessage(userIds, client, data);
        break;
    default:
        throw new Error("Unknown message message type: " + message.type);
    }
}


/**
 * @param {Object} userIds - user descriptor with: uid, email, fullname, fs, clientId 
 * @param {Socket} client  - the just-connected collab client
 */
function onConnect(userIds, client) {
    var userId = userIds.userId;
    var clientId = userIds.clientId;

    console.error("[vfs-collab] CONNECTED UserID: " + userId + " & ClientId: " + clientId);

    client.on("message", function (messag) {
        // console.error("[vfs-collab] Message from ",  userIds, ": " + messag);
        try {
            messag = JSON.parse(messag);
        } catch (e) {
            return console.error("[vfs-collab] Can't parse client data!", messag);
        }
        try {
            handleUserMessage(userIds, client, messag);
        } catch (e) {
            return console.error("[vfs-collab] Can't handle user messag", messag, e);
        }
    });

    handleConnect(userIds, client);

    client.on("disconnect", function () {
        for (var docId in client.openDocIds)
            handleLeaveDocument(userIds, client, {docId: docId, disconnected: true});
        broadcast({
            type: "USER_LEAVE",
            data: {
                userId: userId,
                clientId: clientId
            }
        }, client);
        console.error("[vfs-collab] DISCONNECTED a socket with userId " + userId);
    });
}

var compressTimers = {};

/**
 * Close a document because it's no more open for collaboration, close the watcher and schedule a compression
 * @param {String} docId   - the document id or path
 */
function closeDocument(docId) {
    delete documents[docId];

    if (compressTimers[docId])
        clearTimeout(compressTimers[docId]);
    compressTimers[docId] = setTimeout(function () {
        delete compressTimers[docId];
        compressDocument(docId, {
            MAX_REVISION_NUM: 256,
            COMPRESSED_REV_NUM: 128
        });
    }, 100000);
    
    if (watchers[docId]) {
        watchers[docId].close();
        delete watchers[docId];
    }
}

/**
 * Pack documents' revisions if they go beyond a certain threshould: options.MAX_REVISION_NUM
 * to put it back to a reasonable number of revisions: options.COMPRESSED_REV_NUM
 * 
 * It applies multiple heuristic algorithms to combine revisions trying not to lose any authorship information
 * 
 * @param {String}   docId   - the document id or path
 * @param {Object}   options - compression configuration parameters
 * @param {Function} callback
 */
function compressDocument(docId, options, callback) {
    if (documents[docId])
        return;

    var ALREADY_COMPRESSED = "ALREADY_COMPRESSED";
    var MAX_REVISION_NUM = options.MAX_REVISION_NUM;
    var COMPRESSED_REV_NUM = options.COMPRESSED_REV_NUM;

    var doc, revisions, path;
    var newRevisions, newStarRevNums;
    var starsHash, rev0Contents, lastRevTime, docTimeDiff, optimalRevTimeDiff;

    // compaction modes
    var mergeDifferentAuthors = false;
    var isAggressive = false;

    var secondTime = 1000;
    var minuteTime = secondTime * 60;
    var hourTime = minuteTime * 60;
    var dayTime = hourTime * 24;
    var fourDaysTime = dayTime << 2;

    function done(err) {
        unlock(docId);
        if (err === ALREADY_COMPRESSED)
            err = undefined;
        if (err)
            console.error("[vfs-collab] ERROR Closing Document", docId, err);
        callback && callback(err);
    }

    function cloneRevision(rev, revNum) {
        return {
            document_id: rev.document_id,
            operation: rev.operation.slice(),
            author: rev.author,
            revNum: revNum,
            created_at: rev.created_at,
            updated_at: rev.updated_at
        };
    }

    function shouldMergeTimeDiff(rev, lastRev) {
        if (lastRev.author != rev.author) {
            if (mergeDifferentAuthors)
                lastRev.author = "0";
            else
                return false;
        }

        var latestRevDiff = lastRevTime - rev.created_at;
        var prevRevDiff = rev.created_at - lastRev.created_at;

        if (isAggressive)
            return prevRevDiff < (optimalRevTimeDiff << 1);

        if (latestRevDiff < hourTime)
            // previous revision is < 8-seconds away (co-editing)
            return prevRevDiff < (secondTime << 3);
        else if (latestRevDiff < dayTime)
            // previous revision is < 4-minutes away
            return prevRevDiff < (minuteTime << 2);
        else if (latestRevDiff < fourDaysTime)
            // previous revision is < 1-hour away
            return prevRevDiff < (hourTime);
        else
            return prevRevDiff < optimalRevTimeDiff;
    }

    lock(docId, function() {
        async.series([
            function (next) {
                Store.getDocument(docId, function (err, docL) {
                    if (err || !docL)
                        return next(err || "No document to close!");
                    path = docL.path;
                    doc = docL;
                    next();
                });
            },
            function (next) {
                Store.getRevisions(doc, function (err, revisionsL) {
                    if (err || !revisionsL)
                        return next(err || "No document revisions found!");
                    if (revisionsL.length < MAX_REVISION_NUM)
                        return next(ALREADY_COMPRESSED);
                    revisions = revisionsL;
                    next();
                });
            },
            function prepare(next) {
                // compress to the latest N/2 saves only
                var newStars = doc.starRevNums.slice(-COMPRESSED_REV_NUM);

                starsHash = {};
                var i;
                for (i = 0; i < newStars.length; i++)
                    starsHash[newStars[i]] = true;

                rev0Contents = doc.contents;
                for (i = revisions.length - 1; i > 0; i--) {
                    var op = operations.inverse(revisions[i].operation);
                    revisions[i].contents = rev0Contents;
                    rev0Contents = applyContents(op, rev0Contents);
                }

                lastRevTime = revisions[revisions.length-1].created_at;
                docTimeDiff = lastRevTime - revisions[0].created_at;
                optimalRevTimeDiff = docTimeDiff / COMPRESSED_REV_NUM;

                next();
            },
            function compressDoc(next) {
                var shouldCompress = revisions.length - COMPRESSED_REV_NUM;

                console.error("[vfs-collab] Compress document trial", docId, shouldCompress, mergeDifferentAuthors, isAggressive);

                newRevisions = [ cloneRevision(revisions[0], 0) ];
                newStarRevNums = [];

                var lastRev = {author: -9};
                var prevContents, prevLastContents;
                var lastContents = rev0Contents;
                var i, rev;
                for (i = 1; i < revisions.length && shouldCompress; i++) {
                    rev = revisions[i];
                    prevLastContents = lastContents;
                    lastContents = applyContents(rev.operation, lastContents);
                    // Check if can merge revisions and clear lastRev's author if different & can merge different authors
                    // TODO: remove the side-effect on parameters the function do
                    if (shouldMergeTimeDiff(rev, lastRev)) {
                        var compressedOp = operations.operation(prevContents, lastContents);
                        lastRev.operation = compressedOp;
                        shouldCompress--;
                    }
                    else {
                        lastRev = cloneRevision(rev, newRevisions.length);
                        newRevisions.push(lastRev);
                        prevContents = prevLastContents;
                    }
                    if (starsHash[i] && !lastRev.isStar) {
                        newStarRevNums.push(lastRev.revNum);
                        lastRev.isStar = true;
                    }
                }
                if (!shouldCompress) {
                    while (i < revisions.length) {
                        newRevisions.push(cloneRevision(revisions[i++], newRevisions.length));
                    }
                }
                else if (!mergeDifferentAuthors) {
                    console.error("[vfs-collab] Merge single-author failed to compact the document enough", revisions.length, newRevisions.length);
                    mergeDifferentAuthors = true;
                    return compressDoc(next);
                }
                else if (!isAggressive) {
                    console.error("[vfs-collab] Merge multi-author failed to compact the document enough", revisions.length, newRevisions.length);
                    isAggressive = true;
                    return compressDoc(next);
                }
                else if (newRevisions.length >= MAX_REVISION_NUM) {
                    console.error("[vfs-collab] All compression modes failed to compact the document enough", revisions.length, newRevisions.length);
                }

                console.error("[vfs-collab] Compressed document:", revisions.length, newRevisions.length,
                    "Different Authors:", mergeDifferentAuthors,
                    "isAggressive:", isAggressive);

                // var newContents = rev0Contents;
                // for (i = 1; i < newRevisions.length; i++) {
                //     var newRev = newRevisions[i];
                //     newContents = applyContents(newRev.operation, newContents);
                // }
                // console.error("[vfs-collab] Compressed document:", newContents == doc.contents, revisions.length, newRevisions.length);
                // console.error("[vfs-collab] New Revisions:", newRevisions);
                // console.error("[vfs-collab] Stars:", doc.starRevNums, newStarRevNums);

                next();
            },
            function (next) {
                wrapSeq(Revision.destroy({document_id: doc.id}), next);
            },
            function (next) {
                doc.starRevNums = newStarRevNums;
                doc.revNum = newRevisions.length - 1;
                Store.saveDocument(doc, next);
            },
            function (next) {
                newRevisions.forEach(function(newRev) {
                    delete newRev.isStar;
                    newRev.operation = JSON.stringify(newRev.operation);
                });
                wrapSeq(Revision.bulkCreate(newRevisions), next);
            }
        ], done);
    });
}

// ********* VFS Stream, net.Socket Collab Communication Infrastructure ************ //

/**
 * Create the collab socket net.Server
 * The net.Server is file-socket to allow multiple collab-enabled workspaces on SSH workspaces
 */
function createServer() {
    var server = net.createServer(function(client) {

        // console.error("[vfs-collab] Client connected");
        var userIds;
        var isClosed = false;

        client.send = function (msg) {
            if (isClosed)
                return;
            msg.command = msg.command || "vfs-collab";
            var strMsg = JSON.stringify(msg);
            client.write(strMsg + "\0\0");
        };

        client.on("data", function handShake(data) {
            client.removeListener("data", handShake);
            client.on("data", onData);

            userIds = JSON.parse(data);
            if (!collabReadAccess(userIds.fs))
                return console.error("[vfs-collab] Client don't have read access to workspace! - " +
                    "Note that visitors of private workspaces can't use collab features");

            client.userIds = userIds;
            client.openDocIds = {};
            clients[userIds.clientId] = client;
            // console.error("[vfs-collab] Server handshaked", Object.keys(clients).length);

            // handshaking the client
            client.write(data.toString());

            if (server.collabInited)
                onConnect(userIds, client);
            else
                server.once("collabInited", function() {
                    onConnect(userIds, client);
                });
        });

        var buff = [];

        function onData(data) {
            data = data.toString();
            var idx;
            while (true) {
                idx = data.indexOf("\0\0");
                if (idx === -1)
                    return data && buff.push(data);
                buff.push(data.substring(0, idx));
                var clientMsg = buff.join("");
                data = data.substring(idx + 2);
                buff = [];
                client.emit("message", clientMsg);
            }
        }

        client.on("close", onClose);
        client.on("end", onClose);

        function onClose() {
            if (isClosed)
                return;
            isClosed = true;
            delete clients[userIds.clientId];
            client.emit("disconnect");
            // console.error("[vfs-collab] Client disconnected", Object.keys(clients).length);
        }

        client.on("error", function (err) {
            onClose();
            console.error("[vfs-collab] CLIENT SOCKET ERROR", err);
            client.destroy();
        });
    });
    return server;
}


function initSocket(userIds, callback) {
    var projectWD = getProjectWD();
    var server;

    // file sockets can have multiple servers open on the same path
    // So, we connect first
    var sockPath = process.platform == "win32"
        ? "\\\\.\\pipe\\"+ projectWD +"\\collab.sock"
        : Path.join(projectWD, "collab.sock");
    clientConnect();

    function startServer() {
        server = createServer();
        console.error("[vfs-collab] PID:", PID, "Socket:", sockPath,
             "ClinetId:", userIds.clientId, " & UserId:", userIds.userId);

        async.series([
            function (next) {
                // Create the directoty ~/.c9 if not existing
                Fs.mkdir(Path.dirname(projectWD), function (err) {
                    if (err && err.code !== "EEXIST")
                        return next(err);
                    next();
                });
            },
            function (next) {
                // Create the directoty ~/.c9/$pid if not existing
                Fs.mkdir(projectWD, function (err) {
                    if (err && err.code !== "EEXIST")
                        return next(err);
                    next();
                });
            },
            function (next) {
                // Remove the stale socket, if existing at ~/.c9/$pid/collab.sock
                Fs.unlink(sockPath, function (err) {
                    if (err && err.code !== "ENOENT")
                        return next(err);
                    next();
                });
            },
        ], function(err) {
            if (err)
                return callback(err);

            function closeServerThenCallback(err) {
                try {
                    console.error("[vfs-collab] Shuting down a faulty collab server - reason: ", err);
                    server.close();
                } catch(e) {
                    console.error("[vfs-collab] Can't shutdown faulty collab server", e);
                }
                callback(err);
            }

            server.listen(sockPath, function () {
                isMaster = true;
                server.collabInited = false;

                // init server state
                documents = {};
                watchers = {};
                clients = {};

                // Check server installation, init the server and then connect the client to the inited collab server
                installServer(function (err) {
                    if (err) return closeServerThenCallback(err);

                    initDB(false, function (err) {
                        if (err)
                            return closeServerThenCallback(err);
                        server.collabInited = true;
                        clientConnect();
                        server.emit("collabInited");
                    });
                });

                server.on("close", function () {
                    console.error("[vfs-collab] Server closed");
                    // Should handover to another server (if exists)
                    // e.g. Elect the first client as the new master.
                });
            });

            server.on("error", function (err) {
                // if another connection/thread was able to listen as collab-server, let's just connect to it
                if (err.code === "EADDRINUSE")
                    return clientConnect();
                console.error("[vfs-collab] Server error", err);
            });
        });
    }

    // Connect to a collab client
    // If this fails to connect or the socket file doesn't exist, we try to create the server first
    function clientConnect() {
        var stream = new Stream();
        stream.readable = true;

        var client = net.connect(sockPath, function () {
            client.setTimeout(0);
            client.setNoDelay(true);
            client.setKeepAlive(true);

            client.userIds = userIds;
            client.clientStream = stream;
            // console.error("[vfs-collab] User connected:", userIds.clientId);

            client.on("data", function handShake(data) {
                // console.error("[vfs-collab]", "Client handshaked", data.toString());
                client.removeListener("data", handShake);
                client.on("data", onData);
            });

            var buff = [];

            function onData(data) {
                data = data.toString();
                var idx;
                while (true) {
                    idx = data.indexOf("\0\0");
                    if (idx === -1)
                        return buff.push(data);
                    buff.push(data.substring(0, idx));
                    var streamData = buff.join("");
                    data = data.substring(idx + 2);
                    buff = [];
                    stream.emit("data", streamData);
                }
            }

            client.on("close", function() {
                // console.error("[vfs-collab] Connection closed :", userIds.userId);
                stream.emit("end");
            });

            client.write(JSON.stringify(userIds), "utf8", function() {
                callback(null, client, isMaster && server);
            });
        });

        client.on("error", function (err) {
            if (err && (err.code === "ECONNREFUSED" || err.code === "ENOENT" || err.code === "EAGAIN")) {
                startServer();
            }
            else {
                console.error("[vfs-collab] CLIENT SOCK ERR", err, client.userIds);
                // mock client.write
                client.write = function () {
                    console.error("[vfs-collab] CLIENT SOCK WRITE AFTER ERROR", client.userIds);
                    console.trace();
                };
                stream.emit("end");
            }
        });
    }
}

/**
 * Export the vfs extend API hook
 * Receive the user and project identification thorugh the vfs-extend server-verified options
 * 
 * @param {Vfs}      vfs      - an instance of localfs.js
 * @param {Object}   options  - { user: {}, project: {} }
 * @param {Function} register - register the collab server API
 */
var exports = module.exports = function(vfs, options, register) {

    var vfsClientMap = {};
    localfsAPI = vfs;
    
    if (options.nodePath)
        nodePath = options.nodePath;

    function connect(opts, callback) {
        var user = options.user;
        var project = options.project;
        var clientId = opts.clientId;

        if (!user || !project || !clientId || !opts.basePath)
            return callback(new Error("[OT] Invalid or icomplete collab options passed: " + opts.basePath + " " + clientId ));

        PID = project.pid || project.id;
        basePath = Path.normalize(opts.basePath);

        var userIds = {
            userId: user.uid || user.id,
            email: user.email,
            fullname: user.fullname,
            clientId: clientId,
            fs: options.readonly ? "r" : "rw"
        };

        function cleanOldClient() {
            if (!vfsClientMap[clientId])
                return;
            console.error("[vfs-collab] Disposing old client - possible reconnect?", clientId);
            dispose(clientId);
        }

        cleanOldClient();

        initSocket(userIds, function (err, client, server) {
            if (err)
                return callback(err.message ? err : new Error(err));

            client.netServer = server;

            cleanOldClient();
            vfsClientMap[clientId] = client;

            callback(null, {
                stream: client.clientStream,
                isMaster: isMaster && !!server
            });
        });
    }

    function send(clientId, msg) {
        // console.error("[vfs-collab] IN-STREAM", msg);
        var client = vfsClientMap[clientId];
        if (client)
            client.write(JSON.stringify(msg)+"\0\0");
    }

    function dispose(clientId) {
        var client = vfsClientMap[clientId];
        if (!client)
            return;
        client.end();
        client.destroy();
        // TODO: properly handover
        // if (client.netServer)
        //    client.netServer.close();
        delete vfsClientMap[clientId];
    }

    /**
     * Get a `Document` from the database given its path
     * @param {String}   path the document path to query the database with
     * @param [{String}] attributes - optional
     * @param {Function} callback
     * @param {Object} callback.err
     * @param {Object} callback.result   The result, or null if getDocument() failed (might even though err is null)
     */
    function getDocument(path, attributes, callback) {
        if (!Document) {
            console.log("Initializing collab db for read access");
            return initDB(true, getDocument.bind(null, path, attributes, callback));
        }
        Store.getDocument(path, attributes, callback);
    }

    register(null, {
        connect: connect,
        send: send,
        dispose: dispose,
        getDocument: getDocument,
        emitter: emitter
    });
};

// export for testing
exports.Store = Store;
exports.compressDocument = compressDocument;
exports.checkDBCorruption = checkDBCorruption;
exports.areOperationsMirrored = areOperationsMirrored;
exports.hashString = hashString;
exports.removeNoopOperations = removeNoopOperations;

var DIFF_EQUAL = 0;
var DIFF_INSERT = 1;
var DIFF_DELETE = -1;
var diff_match_patch = require("./diff_match_patch");

// Copied from async
// Can be generically used in many scenarios
var async = function() {

    function forEachSeries(arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed === arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    }

    function series(arr, callback) {
        forEachSeries(arr, function (fn, next) {
            fn.call(null, function (err) {
                if (err)
                    return callback(err);
                next();
            });
        }, callback);
    }

    return {
        series: series,
        forEachSeries: forEachSeries
    };

}();

// Copied from https://github.com/gjtorikian/isBinaryFile
function isBinaryFile(file, callback) {
    var max_bytes = 512;
    exists(file, function (exists) {
        if (!exists)
            return callback(null, false);

        Fs.open(file, 'r', function(err, descriptor) {
            if (err)
                return callback(err);
            var bytes = new Buffer(max_bytes);
            // Read the file with no encoding for raw buffer access.
            Fs.read(descriptor, bytes, 0, bytes.length, 0, function(err, size, bytes) {
                Fs.close(descriptor, function(err2) {
                    if (err || err2)
                        return callback(err || err2);
                    return callback(null, isBinaryCheck(size, bytes));
                });
            });
        });
    });

    function isBinaryCheck(size, bytes) {
        if (size === 0)
            return false;

        var suspicious_bytes = 0;
        var total_bytes = Math.min(size, max_bytes);

        if (size >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) {
            // UTF-8 BOM. This isn't binary.
            return false;
        }

        for (var i = 0; i < total_bytes; i++) {
            if (bytes[i] === 0) { // NULL byte--it's binary!
                return true;
            }
            else if ((bytes[i] < 7 || bytes[i] > 14) && (bytes[i] < 32 || bytes[i] > 127)) {
                // UTF-8 detection
                if (bytes[i] > 191 && bytes[i] < 224 && i + 1 < total_bytes) {
                    i++;
                    if (bytes[i] < 192) {
                        continue;
                    }
                }
                else if (bytes[i] > 223 && bytes[i] < 239 && i + 2 < total_bytes) {
                    i++;
                    if (bytes[i] < 192 && bytes[i + 1] < 192) {
                        i++;
                        continue;
                    }
                }
                suspicious_bytes++;
                // Read at least 32 bytes before making a decision
                if (i > 32 && (suspicious_bytes * 100) / total_bytes > 10) {
                    return true;
                }
            }
        }

        if ((suspicious_bytes * 100) / total_bytes > 10) {
            return true;
        }

        return false;
    }
}

function isVeryLargeFile(file, contents, callback) {
    Fs.stat(file, function(err, stat) {
        if (err) return callback(err);
        
        callback(null, stat.size > 1024 * 1024 || contents && contents.length > 1024 * 1024);
    });
}

});


define('./diff_match_patch', function (module, exports) {

/* Google diff match patch library: https://code.google.com/p/google-diff-match-patch/ */

function diff_match_patch(){this.Diff_Timeout=1;this.Diff_EditCost=4;this.Match_Threshold=0.5;this.Match_Distance=1E3;this.Patch_DeleteThreshold=0.5;this.Patch_Margin=4;this.Match_MaxBits=32}
diff_match_patch.prototype.diff_main=function(a,b,c,d){"undefined"==typeof d&&(d=0>=this.Diff_Timeout?Number.MAX_VALUE:(new Date).getTime()+1E3*this.Diff_Timeout);if(null==a||null==b)throw Error("Null input. (diff_main)");if(a==b)return a?[[0,a]]:[];"undefined"==typeof c&&(c=!0);var e=c,f=this.diff_commonPrefix(a,b),c=a.substring(0,f),a=a.substring(f),b=b.substring(f),f=this.diff_commonSuffix(a,b),g=a.substring(a.length-f),a=a.substring(0,a.length-f),b=b.substring(0,b.length-f),a=this.diff_compute_(a,b,e,d);c&&a.unshift([0,c]);g&&a.push([0,g]);this.diff_cleanupMerge(a);return a};
diff_match_patch.prototype.diff_compute_=function(a,b,c,d){if(!a)return[[1,b]];if(!b)return[[-1,a]];var e=a.length>b.length?a:b,f=a.length>b.length?b:a,g=e.indexOf(f);if(-1!=g)return c=[[1,e.substring(0,g)],[0,f],[1,e.substring(g+f.length)]],a.length>b.length&&(c[0][0]=c[2][0]=-1),c;if(1==f.length)return[[-1,a],[1,b]];return(e=this.diff_halfMatch_(a,b))?(f=e[0],a=e[1],g=e[2],b=e[3],e=e[4],f=this.diff_main(f,g,c,d),c=this.diff_main(a,b,c,d),f.concat([[0,e]],c)):c&&100<a.length&&100<b.length?this.diff_lineMode_(a,b,d):this.diff_bisect_(a,b,d)};
diff_match_patch.prototype.diff_lineMode_=function(a,b,c){var d=this.diff_linesToChars_(a,b),a=d.chars1,b=d.chars2,d=d.lineArray,a=this.diff_main(a,b,!1,c);this.diff_charsToLines_(a,d);this.diff_cleanupSemantic(a);a.push([0,""]);for(var e=d=b=0,f="",g="";b<a.length;){switch(a[b][0]){case 1:e++;g+=a[b][1];break;case -1:d++;f+=a[b][1];break;case 0:if(1<=d&&1<=e){a.splice(b-d-e,d+e);b=b-d-e;d=this.diff_main(f,g,!1,c);for(e=d.length-1;0<=e;e--)a.splice(b,0,d[e]);b+=d.length}d=e=0;g=f=""}b++}a.pop();return a};
diff_match_patch.prototype.diff_bisect_=function(a,b,c){for(var d=a.length,e=b.length,f=Math.ceil((d+e)/2),g=f,h=2*f,j=Array(h),i=Array(h),k=0;k<h;k++)j[k]=-1,i[k]=-1;j[g+1]=0;i[g+1]=0;for(var k=d-e,p=0!=k%2,q=0,s=0,o=0,v=0,u=0;u<f&&!((new Date).getTime()>c);u++){for(var n=-u+q;n<=u-s;n+=2){var l=g+n,m;m=n==-u||n!=u&&j[l-1]<j[l+1]?j[l+1]:j[l-1]+1;for(var r=m-n;m<d&&r<e&&a.charAt(m)==b.charAt(r);)m++,r++;j[l]=m;if(m>d)s+=2;else if(r>e)q+=2;else if(p&&(l=g+k-n,0<=l&&l<h&&-1!=i[l])){var t=d-i[l];if(m>=t)return this.diff_bisectSplit_(a,b,m,r,c)}}for(n=-u+o;n<=u-v;n+=2){l=g+n;t=n==-u||n!=u&&i[l-1]<i[l+1]?i[l+1]:i[l-1]+1;for(m=t-n;t<d&&m<e&&a.charAt(d-t-1)==b.charAt(e-m-1);)t++,m++;i[l]=t;if(t>d)v+=2;else if(m>e)o+=2;else if(!p&&(l=g+k-n,0<=l&&l<h&&-1!=j[l]&&(m=j[l],r=g+m-l,t=d-t,m>=t)))return this.diff_bisectSplit_(a,b,m,r,c)}}return[[-1,a],[1,b]]};
diff_match_patch.prototype.diff_bisectSplit_=function(a,b,c,d,e){var f=a.substring(0,c),g=b.substring(0,d),a=a.substring(c),b=b.substring(d),f=this.diff_main(f,g,!1,e),e=this.diff_main(a,b,!1,e);return f.concat(e)};
diff_match_patch.prototype.diff_linesToChars_=function(a,b){function c(a){for(var b="",c=0,f=-1,g=d.length;f<a.length-1;){f=a.indexOf("\n",c);-1==f&&(f=a.length-1);var q=a.substring(c,f+1),c=f+1;(e.hasOwnProperty?e.hasOwnProperty(q):void 0!==e[q])?b+=String.fromCharCode(e[q]):(b+=String.fromCharCode(g),e[q]=g,d[g++]=q)}return b}var d=[],e={};d[0]="";var f=c(a),g=c(b);return{chars1:f,chars2:g,lineArray:d}};
diff_match_patch.prototype.diff_charsToLines_=function(a,b){for(var c=0;c<a.length;c++){for(var d=a[c][1],e=[],f=0;f<d.length;f++)e[f]=b[d.charCodeAt(f)];a[c][1]=e.join("")}};diff_match_patch.prototype.diff_commonPrefix=function(a,b){if(!a||!b||a.charAt(0)!=b.charAt(0))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(f,e)==b.substring(f,e)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};
diff_match_patch.prototype.diff_commonSuffix=function(a,b){if(!a||!b||a.charAt(a.length-1)!=b.charAt(b.length-1))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(a.length-e,a.length-f)==b.substring(b.length-e,b.length-f)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};
diff_match_patch.prototype.diff_commonOverlap_=function(a,b){var c=a.length,d=b.length;if(0==c||0==d)return 0;c>d?a=a.substring(c-d):c<d&&(b=b.substring(0,c));c=Math.min(c,d);if(a==b)return c;for(var d=0,e=1;;){var f=a.substring(c-e),f=b.indexOf(f);if(-1==f)return d;e+=f;if(0==f||a.substring(c-e)==b.substring(0,e))d=e,e++}};
diff_match_patch.prototype.diff_halfMatch_=function(a,b){function c(a,b,c){for(var d=a.substring(c,c+Math.floor(a.length/4)),e=-1,g="",h,j,n,l;-1!=(e=b.indexOf(d,e+1));){var m=f.diff_commonPrefix(a.substring(c),b.substring(e)),r=f.diff_commonSuffix(a.substring(0,c),b.substring(0,e));g.length<r+m&&(g=b.substring(e-r,e)+b.substring(e,e+m),h=a.substring(0,c-r),j=a.substring(c+m),n=b.substring(0,e-r),l=b.substring(e+m))}return 2*g.length>=a.length?[h,j,n,l,g]:null}if(0>=this.Diff_Timeout)return null;var d=a.length>b.length?a:b,e=a.length>b.length?b:a;if(4>d.length||2*e.length<d.length)return null;var f=this,g=c(d,e,Math.ceil(d.length/4)),d=c(d,e,Math.ceil(d.length/2)),h;if(!g&&!d)return null;h=d?g?g[4].length>d[4].length?g:d:d:g;var j;a.length>b.length?(g=h[0],d=h[1],e=h[2],j=h[3]):(e=h[0],j=h[1],g=h[2],d=h[3]);h=h[4];return[g,d,e,j,h]};
diff_match_patch.prototype.diff_cleanupSemantic=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=0,h=0,j=0,i=0;f<a.length;)0==a[f][0]?(c[d++]=f,g=j,h=i,i=j=0,e=a[f][1]):(1==a[f][0]?j+=a[f][1].length:i+=a[f][1].length,e&&e.length<=Math.max(g,h)&&e.length<=Math.max(j,i)&&(a.splice(c[d-1],0,[-1,e]),a[c[d-1]+1][0]=1,d--,d--,f=0<d?c[d-1]:-1,i=j=h=g=0,e=null,b=!0)),f++;b&&this.diff_cleanupMerge(a);this.diff_cleanupSemanticLossless(a);for(f=1;f<a.length;){if(-1==a[f-1][0]&&1==a[f][0]){b=a[f-1][1];c=a[f][1];d=this.diff_commonOverlap_(b,c);e=this.diff_commonOverlap_(c,b);if(d>=e){if(d>=b.length/2||d>=c.length/2)a.splice(f,0,[0,c.substring(0,d)]),a[f-1][1]=b.substring(0,b.length-d),a[f+1][1]=c.substring(d),f++}else if(e>=b.length/2||e>=c.length/2)a.splice(f,0,[0,b.substring(0,e)]),a[f-1][0]=1,a[f-1][1]=c.substring(0,c.length-e),a[f+1][0]=-1,a[f+1][1]=b.substring(e),f++;f++}f++}};
diff_match_patch.prototype.diff_cleanupSemanticLossless=function(a){function b(a,b){if(!a||!b)return 6;var c=a.charAt(a.length-1),d=b.charAt(0),e=c.match(diff_match_patch.nonAlphaNumericRegex_),f=d.match(diff_match_patch.nonAlphaNumericRegex_),g=e&&c.match(diff_match_patch.whitespaceRegex_),h=f&&d.match(diff_match_patch.whitespaceRegex_),c=g&&c.match(diff_match_patch.linebreakRegex_),d=h&&d.match(diff_match_patch.linebreakRegex_),i=c&&a.match(diff_match_patch.blanklineEndRegex_),j=d&&b.match(diff_match_patch.blanklineStartRegex_);return i||j?5:c||d?4:e&&!g&&h?3:g||h?2:e||f?1:0}for(var c=1;c<a.length-1;){if(0==a[c-1][0]&&0==a[c+1][0]){var d=a[c-1][1],e=a[c][1],f=a[c+1][1],g=this.diff_commonSuffix(d,e);if(g)var h=e.substring(e.length-g),d=d.substring(0,d.length-g),e=h+e.substring(0,e.length-g),f=h+f;for(var g=d,h=e,j=f,i=b(d,e)+b(e,f);e.charAt(0)===f.charAt(0);){var d=d+e.charAt(0),e=e.substring(1)+f.charAt(0),f=f.substring(1),k=b(d,e)+b(e,f);k>=i&&(i=k,g=d,h=e,j=f)}a[c-1][1]!=g&&(g?a[c-1][1]=g:(a.splice(c-1,1),c--),a[c][1]=h,j?a[c+1][1]=j:(a.splice(c+1,1),c--))}c++}};diff_match_patch.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/;diff_match_patch.whitespaceRegex_=/\s/;diff_match_patch.linebreakRegex_=/[\r\n]/;diff_match_patch.blanklineEndRegex_=/\n\r?\n$/;diff_match_patch.blanklineStartRegex_=/^\r?\n\r?\n/;
diff_match_patch.prototype.diff_cleanupEfficiency=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=!1,h=!1,j=!1,i=!1;f<a.length;){if(0==a[f][0])a[f][1].length<this.Diff_EditCost&&(j||i)?(c[d++]=f,g=j,h=i,e=a[f][1]):(d=0,e=null),j=i=!1;else if(-1==a[f][0]?i=!0:j=!0,e&&(g&&h&&j&&i||e.length<this.Diff_EditCost/2&&3==g+h+j+i))a.splice(c[d-1],0,[-1,e]),a[c[d-1]+1][0]=1,d--,e=null,g&&h?(j=i=!0,d=0):(d--,f=0<d?c[d-1]:-1,j=i=!1),b=!0;f++}b&&this.diff_cleanupMerge(a)};
diff_match_patch.prototype.diff_cleanupMerge=function(a){a.push([0,""]);for(var b=0,c=0,d=0,e="",f="",g;b<a.length;)switch(a[b][0]){case 1:d++;f+=a[b][1];b++;break;case -1:c++;e+=a[b][1];b++;break;case 0:1<c+d?(0!==c&&0!==d&&(g=this.diff_commonPrefix(f,e),0!==g&&(0<b-c-d&&0==a[b-c-d-1][0]?a[b-c-d-1][1]+=f.substring(0,g):(a.splice(0,0,[0,f.substring(0,g)]),b++),f=f.substring(g),e=e.substring(g)),g=this.diff_commonSuffix(f,e),0!==g&&(a[b][1]=f.substring(f.length-g)+a[b][1],f=f.substring(0,f.length-g),e=e.substring(0,e.length-g))),0===c?a.splice(b-d,c+d,[1,f]):0===d?a.splice(b-c,c+d,[-1,e]):a.splice(b-c-d,c+d,[-1,e],[1,f]),b=b-c-d+(c?1:0)+(d?1:0)+1):0!==b&&0==a[b-1][0]?(a[b-1][1]+=a[b][1],a.splice(b,1)):b++,c=d=0,f=e=""}""===a[a.length-1][1]&&a.pop();c=!1;for(b=1;b<a.length-1;)0==a[b-1][0]&&0==a[b+1][0]&&(a[b][1].substring(a[b][1].length-a[b-1][1].length)==a[b-1][1]?(a[b][1]=a[b-1][1]+a[b][1].substring(0,a[b][1].length-a[b-1][1].length),a[b+1][1]=a[b-1][1]+a[b+1][1],a.splice(b-1,1),c=!0):a[b][1].substring(0,a[b+1][1].length)==a[b+1][1]&&(a[b-1][1]+=a[b+1][1],a[b][1]=a[b][1].substring(a[b+1][1].length)+a[b+1][1],a.splice(b+1,1),c=!0)),b++;c&&this.diff_cleanupMerge(a)};
diff_match_patch.prototype.diff_xIndex=function(a,b){var c=0,d=0,e=0,f=0,g;for(g=0;g<a.length;g++){1!==a[g][0]&&(c+=a[g][1].length);-1!==a[g][0]&&(d+=a[g][1].length);if(c>b)break;e=c;f=d}return a.length!=g&&-1===a[g][0]?f:f+(b-e)};
diff_match_patch.prototype.diff_prettyHtml=function(a){for(var b=[],c=/&/g,d=/</g,e=/>/g,f=/\n/g,g=0;g<a.length;g++){var h=a[g][0],j=a[g][1],j=j.replace(c,"&amp;").replace(d,"&lt;").replace(e,"&gt;").replace(f,"&para;<br>");switch(h){case 1:b[g]='<ins style="background:#e6ffe6;">'+j+"</ins>";break;case -1:b[g]='<del style="background:#ffe6e6;">'+j+"</del>";break;case 0:b[g]="<span>"+j+"</span>"}}return b.join("")};
diff_match_patch.prototype.diff_text1=function(a){for(var b=[],c=0;c<a.length;c++)1!==a[c][0]&&(b[c]=a[c][1]);return b.join("")};
diff_match_patch.prototype.diff_text2=function(a){for(var b=[],c=0;c<a.length;c++)-1!==a[c][0]&&(b[c]=a[c][1]);return b.join("")};
diff_match_patch.prototype.diff_levenshtein=function(a){for(var b=0,c=0,d=0,e=0;e<a.length;e++){var f=a[e][0],g=a[e][1];switch(f){case 1:c+=g.length;break;case -1:d+=g.length;break;case 0:b+=Math.max(c,d),d=c=0}}return b+=Math.max(c,d)};
diff_match_patch.prototype.diff_toDelta=function(a){for(var b=[],c=0;c<a.length;c++)switch(a[c][0]){case 1:b[c]="+"+encodeURI(a[c][1]);break;case -1:b[c]="-"+a[c][1].length;break;case 0:b[c]="="+a[c][1].length}return b.join("\t").replace(/%20/g," ")};
diff_match_patch.prototype.diff_fromDelta=function(a,b){for(var c=[],d=0,e=0,f=b.split(/\t/g),g=0;g<f.length;g++){var h=f[g].substring(1);switch(f[g].charAt(0)){case "+":try{c[d++]=[1,decodeURI(h)]}catch(j){throw Error("Illegal escape in diff_fromDelta: "+h);}break;case "-":case "=":var i=parseInt(h,10);if(isNaN(i)||0>i)throw Error("Invalid number in diff_fromDelta: "+h);h=a.substring(e,e+=i);"="==f[g].charAt(0)?c[d++]=[0,h]:c[d++]=[-1,h];break;default:if(f[g])throw Error("Invalid diff operation in diff_fromDelta: "+f[g]);}}if(e!=a.length)throw Error("Delta length ("+e+") does not equal source text length ("+a.length+").");return c};
diff_match_patch.prototype.match_main=function(a,b,c){if(null==a||null==b||null==c)throw Error("Null input. (match_main)");c=Math.max(0,Math.min(c,a.length));return a==b?0:a.length?a.substring(c,c+b.length)==b?c:this.match_bitap_(a,b,c):-1};
diff_match_patch.prototype.match_bitap_=function(a,b,c){function d(a,d){var e=a/b.length,g=Math.abs(c-d);return!f.Match_Distance?g?1:e:e+g/f.Match_Distance}if(b.length>this.Match_MaxBits)throw Error("Pattern too long for this browser.");var e=this.match_alphabet_(b),f=this,g=this.Match_Threshold,h=a.indexOf(b,c);-1!=h&&(g=Math.min(d(0,h),g),h=a.lastIndexOf(b,c+b.length),-1!=h&&(g=Math.min(d(0,h),g)));for(var j=1<<b.length-1,h=-1,i,k,p=b.length+a.length,q,s=0;s<b.length;s++){i=0;for(k=p;i<k;)d(s,c+k)<=g?i=k:p=k,k=Math.floor((p-i)/2+i);p=k;i=Math.max(1,c-k+1);var o=Math.min(c+k,a.length)+b.length;k=Array(o+2);for(k[o+1]=(1<<s)-1;o>=i;o--){var v=e[a.charAt(o-1)];k[o]=0===s?(k[o+1]<<1|1)&v:(k[o+1]<<1|1)&v|(q[o+1]|q[o])<<1|1|q[o+1];if(k[o]&j&&(v=d(s,o-1),v<=g))if(g=v,h=o-1,h>c)i=Math.max(1,2*c-h);else break}if(d(s+1,c)>g)break;q=k}return h};
diff_match_patch.prototype.match_alphabet_=function(a){for(var b={},c=0;c<a.length;c++)b[a.charAt(c)]=0;for(c=0;c<a.length;c++)b[a.charAt(c)]|=1<<a.length-c-1;return b};
diff_match_patch.prototype.patch_addContext_=function(a,b){if(0!=b.length){for(var c=b.substring(a.start2,a.start2+a.length1),d=0;b.indexOf(c)!=b.lastIndexOf(c)&&c.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)d+=this.Patch_Margin,c=b.substring(a.start2-d,a.start2+a.length1+d);d+=this.Patch_Margin;(c=b.substring(a.start2-d,a.start2))&&a.diffs.unshift([0,c]);(d=b.substring(a.start2+a.length1,a.start2+a.length1+d))&&a.diffs.push([0,d]);a.start1-=c.length;a.start2-=c.length;a.length1+=c.length+d.length;a.length2+=c.length+d.length}};
diff_match_patch.prototype.patch_make=function(a,b,c){var d;if("string"==typeof a&&"string"==typeof b&&"undefined"==typeof c)d=a,b=this.diff_main(d,b,!0),2<b.length&&(this.diff_cleanupSemantic(b),this.diff_cleanupEfficiency(b));else if(a&&"object"==typeof a&&"undefined"==typeof b&&"undefined"==typeof c)b=a,d=this.diff_text1(b);else if("string"==typeof a&&b&&"object"==typeof b&&"undefined"==typeof c)d=a;else if("string"==typeof a&&"string"==typeof b&&c&&"object"==typeof c)d=a,b=c;else throw Error("Unknown call format to patch_make.");if(0===b.length)return[];for(var c=[],a=new diff_match_patch.patch_obj,e=0,f=0,g=0,h=d,j=0;j<b.length;j++){var i=b[j][0],k=b[j][1];if(!e&&0!==i)a.start1=f,a.start2=g;switch(i){case 1:a.diffs[e++]=b[j];a.length2+=k.length;d=d.substring(0,g)+k+d.substring(g);break;case -1:a.length1+=k.length;a.diffs[e++]=b[j];d=d.substring(0,g)+d.substring(g+k.length);break;case 0:k.length<=2*this.Patch_Margin&&e&&b.length!=j+1?(a.diffs[e++]=b[j],a.length1+=k.length,a.length2+=k.length):k.length>=2*this.Patch_Margin&&e&&(this.patch_addContext_(a,h),c.push(a),a=new diff_match_patch.patch_obj,e=0,h=d,f=g)}1!==i&&(f+=k.length);-1!==i&&(g+=k.length)}e&&(this.patch_addContext_(a,h),c.push(a));return c};
diff_match_patch.prototype.patch_deepCopy=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=new diff_match_patch.patch_obj;e.diffs=[];for(var f=0;f<d.diffs.length;f++)e.diffs[f]=d.diffs[f].slice();e.start1=d.start1;e.start2=d.start2;e.length1=d.length1;e.length2=d.length2;b[c]=e}return b};
diff_match_patch.prototype.patch_apply=function(a,b){if(0==a.length)return[b,[]];var a=this.patch_deepCopy(a),c=this.patch_addPadding(a),b=c+b+c;this.patch_splitMax(a);for(var d=0,e=[],f=0;f<a.length;f++){var g=a[f].start2+d,h=this.diff_text1(a[f].diffs),j,i=-1;if(h.length>this.Match_MaxBits){if(j=this.match_main(b,h.substring(0,this.Match_MaxBits),g),-1!=j&&(i=this.match_main(b,h.substring(h.length-this.Match_MaxBits),g+h.length-this.Match_MaxBits),-1==i||j>=i))j=-1}else j=this.match_main(b,h,g);if(-1==j)e[f]=!1,d-=a[f].length2-a[f].length1;else if(e[f]=!0,d=j-g,g=-1==i?b.substring(j,j+h.length):b.substring(j,i+this.Match_MaxBits),h==g)b=b.substring(0,j)+this.diff_text2(a[f].diffs)+b.substring(j+h.length);else if(g=this.diff_main(h,g,!1),h.length>this.Match_MaxBits&&this.diff_levenshtein(g)/h.length>this.Patch_DeleteThreshold)e[f]=!1;else{this.diff_cleanupSemanticLossless(g);for(var h=0,k,i=0;i<a[f].diffs.length;i++){var p=a[f].diffs[i];0!==p[0]&&(k=this.diff_xIndex(g,h));1===p[0]?b=b.substring(0,j+k)+p[1]+b.substring(j+k):-1===p[0]&&(b=b.substring(0,j+k)+b.substring(j+this.diff_xIndex(g,h+p[1].length)));-1!==p[0]&&(h+=p[1].length)}}}b=b.substring(c.length,b.length-c.length);return[b,e]};
diff_match_patch.prototype.patch_addPadding=function(a){for(var b=this.Patch_Margin,c="",d=1;d<=b;d++)c+=String.fromCharCode(d);for(d=0;d<a.length;d++)a[d].start1+=b,a[d].start2+=b;var d=a[0],e=d.diffs;if(0==e.length||0!=e[0][0])e.unshift([0,c]),d.start1-=b,d.start2-=b,d.length1+=b,d.length2+=b;else if(b>e[0][1].length){var f=b-e[0][1].length;e[0][1]=c.substring(e[0][1].length)+e[0][1];d.start1-=f;d.start2-=f;d.length1+=f;d.length2+=f}d=a[a.length-1];e=d.diffs;0==e.length||0!=e[e.length-1][0]?(e.push([0,c]),d.length1+=b,d.length2+=b):b>e[e.length-1][1].length&&(f=b-e[e.length-1][1].length,e[e.length-1][1]+=c.substring(0,f),d.length1+=f,d.length2+=f);return c};
diff_match_patch.prototype.patch_splitMax=function(a){for(var b=this.Match_MaxBits,c=0;c<a.length;c++)if(!(a[c].length1<=b)){var d=a[c];a.splice(c--,1);for(var e=d.start1,f=d.start2,g="";0!==d.diffs.length;){var h=new diff_match_patch.patch_obj,j=!0;h.start1=e-g.length;h.start2=f-g.length;if(""!==g)h.length1=h.length2=g.length,h.diffs.push([0,g]);for(;0!==d.diffs.length&&h.length1<b-this.Patch_Margin;){var g=d.diffs[0][0],i=d.diffs[0][1];1===g?(h.length2+=i.length,f+=i.length,h.diffs.push(d.diffs.shift()),j=!1):-1===g&&1==h.diffs.length&&0==h.diffs[0][0]&&i.length>2*b?(h.length1+=i.length,e+=i.length,j=!1,h.diffs.push([g,i]),d.diffs.shift()):(i=i.substring(0,b-h.length1-this.Patch_Margin),h.length1+=i.length,e+=i.length,0===g?(h.length2+=i.length,f+=i.length):j=!1,h.diffs.push([g,i]),i==d.diffs[0][1]?d.diffs.shift():d.diffs[0][1]=d.diffs[0][1].substring(i.length))}g=this.diff_text2(h.diffs);g=g.substring(g.length-this.Patch_Margin);i=this.diff_text1(d.diffs).substring(0,this.Patch_Margin);""!==i&&(h.length1+=i.length,h.length2+=i.length,0!==h.diffs.length&&0===h.diffs[h.diffs.length-1][0]?h.diffs[h.diffs.length-1][1]+=i:h.diffs.push([0,i]));j||a.splice(++c,0,h)}}};
diff_match_patch.prototype.patch_toText=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=a[c];return b.join("")};
diff_match_patch.prototype.patch_fromText=function(a){var b=[];if(!a)return b;for(var a=a.split("\n"),c=0,d=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;c<a.length;){var e=a[c].match(d);if(!e)throw Error("Invalid patch string: "+a[c]);var f=new diff_match_patch.patch_obj;b.push(f);f.start1=parseInt(e[1],10);""===e[2]?(f.start1--,f.length1=1):"0"==e[2]?f.length1=0:(f.start1--,f.length1=parseInt(e[2],10));f.start2=parseInt(e[3],10);""===e[4]?(f.start2--,f.length2=1):"0"==e[4]?f.length2=0:(f.start2--,f.length2=parseInt(e[4],10));for(c++;c<a.length;){e=a[c].charAt(0);try{var g=decodeURI(a[c].substring(1))}catch(h){throw Error("Illegal escape in patch_fromText: "+g);}if("-"==e)f.diffs.push([-1,g]);else if("+"==e)f.diffs.push([1,g]);else if(" "==e)f.diffs.push([0,g]);else if("@"==e)break;else if(""!==e)throw Error('Invalid patch mode "'+e+'" in: '+g);c++}}return b};
diff_match_patch.patch_obj=function(){this.diffs=[];this.start2=this.start1=null;this.length2=this.length1=0};
diff_match_patch.patch_obj.prototype.toString=function(){var a,b;a=0===this.length1?this.start1+",0":1==this.length1?this.start1+1:this.start1+1+","+this.length1;b=0===this.length2?this.start2+",0":1==this.length2?this.start2+1:this.start2+1+","+this.length2;a=["@@ -"+a+" +"+b+" @@\n"];var c;for(b=0;b<this.diffs.length;b++){switch(this.diffs[b][0]){case 1:c="+";break;case -1:c="-";break;case 0:c=" "}a[b+1]=c+encodeURI(this.diffs[b][1])+"\n"}return a.join("").replace(/%20/g," ")};

/* diff match patch end */
module.exports = diff_match_patch;
});


define('c9.ide.pubsub/pubsub-service.js', function (module, exports) {

module.exports = function (vfs, options, register) {
    var Stream = require('stream');
    
    var stream = new Stream();
    stream.readable = true;

    register(null, {
        subscribe: function (callback) {
            callback(null, { stream: stream });
        },

        publish: function(message) {
            stream.emit("data", message);
        }
    });
};

});


define('c9.vfs.client/ping-service.js', function (module, exports) {

module.exports = function(vfs, options, register) {
    register(null, {
        ping: function (payload, callback) {
            // We simply return the payload, while vfs-socket adds a time stamp
            callback(null, payload);
        }
    });
};

});


define('smith', function (module, exports) {

/*
Copyright (c) 2012 Ajax.org B.V

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
( // Module boilerplate to support browser globals, node.js and AMD.
  (typeof module !== "undefined" && function (m) { module.exports = m(require('events'), require('msgpack-js')); }) ||
  (typeof define === "function" && function (m) { define("smith", ["events", "msgpack-js"], m); }) ||
  (function (m) { window.smith = m(window.events, window.msgpack); })
)(function (events, msgpack) {
"use strict";
var EventEmitter = events.EventEmitter;

function inherits(Child, Parent) {
  Child.prototype = Object.create(Parent.prototype, { constructor: { value: Child }});
}

var exports = {};

exports.msgpack = msgpack;
exports.Agent = Agent;
exports.Transport = Transport;
exports.deFramer = deFramer;
exports.liven = liven;
exports.freeze = freeze;
exports.getType = getType;

////////////////////////////////////////////////////////////////////////////////

// Transport is a connection between two Agents.  It lives on top of a duplex,
// binary stream.
// @input - the stream we listen for data on
// @output - the stream we write to (can be the same object as input)
// @send(message) - send a message to the other side
// "message" - event emitted when we get a message from the other side.
// "disconnect" - the transport was disconnected
// "error" - event emitted for stream error or disconnect
// "drain" - drain event from output stream
function Transport(input) {
    var self = this;
    var output;
    if (Array.isArray(input)) {
        output = input[1];
        input = input[0];
    } else {
        output = input;
    }
    this.input = input;
    this.output = output;

    if (!input.readable) throw new Error("Input is not readable");
    if (!output.writable) throw new Error("Output is not writable");

    // Attach event listeners
    input.on("data", onData);
    input.on("end", onDisconnect);
    input.on("timeout", onDisconnect);
    input.on("close", onDisconnect);
    input.on("error", onError);
    output.on("drain", onDrain);
    if (output !== input) {
        output.on("end", onDisconnect);
        output.on("timeout", onDisconnect);
        output.on("close", onDisconnect);
        output.on("error", onError);
    }

    var parse = deFramer(function(err, frame) {
        if (err)
            return self.emit("error", err);
        
        var message;
        try {
            message = msgpack.decode(frame);
        } catch (err) {
            return self.emit("error", err);
        }

        exports.debug && console.log(process.pid + " <- " + require('util').inspect(message, false, 2, true));
        self.emit("message", message);
    });

    // Route data chunks to the parser, but check for errors
    function onData(chunk) {
        parse(chunk);
    }

    // Forward drain events from the writable stream
    function onDrain() {
        self.emit("drain");
    }
    // Forward all error events to the transport
    function onError(err) {
        self.emit("error", err);
    }
    function onDisconnect() {
        // Remove all the listeners we added and destroy the streams
        input.removeListener("data", onData);
        input.removeListener("end", onDisconnect);
        input.removeListener("timeout", onDisconnect);
        input.removeListener("close", onDisconnect);
        output.removeListener("drain", onDrain);
        if (input.destroy) input.destroy();
        if (input !== output) {
            output.removeListener("end", onDisconnect);
            output.removeListener("timeout", onDisconnect);
            output.removeListener("close", onDisconnect);
            if (output.destroy && output !== process.stdout) output.destroy();
        }
        self.emit("disconnect");
    }
    this.disconnect = onDisconnect;
}
inherits(Transport, EventEmitter);

Transport.prototype.send = function (message) {
    // Uncomment to debug protocol
    exports.debug && console.log(process.pid + " -> " + require('util').inspect(message, false, 2, true));

    // Serialize the messsage.
    var frame = msgpack.encode(message);

    // Send a 4 byte length header before the frame.
    var header = new Buffer(10);
    header.writeUInt32BE(frame.length, 0);

    // Compute 4 byte jenkins hash
    var a = frame.length >> 24,
        b = (frame.length >> 16) & 0xff,
        c = (frame.length >> 8) & 0xff,
        d = frame.length & 0xff;

    // Little bit inlined, but fast
    var hash = 0;
    hash += a;
    hash += hash << 10;
    hash += hash >> 6;
    hash += b;
    hash += hash << 10;
    hash += hash >> 6;
    hash += c;
    hash += hash << 10;
    hash += hash >> 6;
    hash += d;
    hash += hash << 10;
    hash += hash >> 6;

    // Shuffle bits
    hash += hash << 3;
    hash = hash ^ (hash >> 11);
    hash += hash << 15;
    hash |= 0;
    header.writeInt32BE(hash, 4, true);

    // 2 Reserved bytes for future usage
    header.writeUInt16BE(0, 8);

    this.output.write(header);


    // Send the serialized message.
    return this.output.write(frame);
};

// A simple state machine that consumes raw bytes and emits frame events.
// Returns a parser function that consumes buffers.  It emits message buffers
// via onMessage callback passed in.
function deFramer(onFrame) {
    var buffer;
    var state = 0;
    var length = 0;
    var expected_hash = 0;
    var hash = 0;
    var offset;
    return function parse(chunk) {
        for (var i = 0, l = chunk.length; i < l; i++) {
            switch (state) {
            case 0:
                length |= chunk[i] << 24;
                expected_hash = 0;
                state = 1;
                break;
            case 1: length |= chunk[i] << 16; state = 2; break;
            case 2: length |= chunk[i] << 8; state = 3; break;
            case 3:
                length |= chunk[i];
                expected_hash += chunk[i];
                expected_hash += expected_hash << 10;
                expected_hash += expected_hash >> 6;

                // Shuffle bits
                expected_hash += expected_hash << 3;
                expected_hash = expected_hash ^ (expected_hash >> 11);
                expected_hash += expected_hash << 15;
                expected_hash |= 0;

                hash = 0;
                state = 4;
                break;
            case 4: hash |= chunk[i] << 24; state = 5; break;
            case 5: hash |= chunk[i] << 16; state = 6; break;
            case 6: hash |= chunk[i] << 8; state = 7; break;
            case 7: hash |= chunk[i]; state = 8;
                if (hash !== expected_hash) {
                    return onFrame(new Error("Hash mismatch, expected: " + expected_hash +
                                  " got: " + hash + ", chunk: " + chunk));
                }

                if (length > 100 * 1024 * 1024) {
                    return onFrame(new Error("Too big buffer " + length +
                                  ", chunk: " + chunk));
                }

                buffer = new Buffer(length);
                offset = 0;
                state = 9;
                break;
            // Two reserved bytes
            case 9: state = 10; break;
            case 10: state = 11; break;

            // Data itself
            case 11:
                var len = l - i;
                var emit = false;
                if (len + offset >= length) {
                    emit = true;
                    len = length - offset;
                }
                // TODO: optimize for case where a copy isn't needed can a slice can
                // be used instead?
                chunk.copy(buffer, offset, i, i + len);
                offset += len;
                i += len - 1;
                if (emit) {
                    onFrame(null, buffer);
                    state = 0;
                    length = 0;
                    buffer = undefined;
                    offset = undefined;
                }
                break;
            }

            // Common case
            if (state <= 3 && !emit) {
              expected_hash += chunk[i];
              expected_hash += expected_hash << 10;
              expected_hash += expected_hash >> 6;
            }

            emit = false;
        }
    };
}

////////////////////////////////////////////////////////////////////////////////

// Agent is an API serving node in the architect-agent rpc mesh.  It contains
// a table of functions that actually do the work and serve them to a Agent
// agent.  An agent can connect to one other agent at a time.
function Agent(api) {
    if (!this instanceof Agent) throw new Error("Forgot to use new with Agent constructor");

    this.api = api || {};

    // Bind event handlers and callbacks
    this.disconnect = this.disconnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._onDrain = this._onDrain.bind(this);
    this._onReady = this._onReady.bind(this);
    this._getFunction = this._getFunction.bind(this);
    this._storeFunction = this._storeFunction.bind(this);

    this.remoteApi = {}; // Persist the API object between connections
    this.transport = undefined;
    this.callbacks = undefined;
    this.nextKey = undefined;
}
inherits(Agent, EventEmitter);

// Time to wait for Agent connections to finish
Agent.prototype.connectionTimeout = 10000;

Agent.prototype.connect = function (transport, callback) {
    // If they passed in a raw stream, wrap it.
    if (!(transport instanceof Transport))
        transport = new Transport(transport);

    this.transport = transport;
    this.callbacks = {};
    this.nextKey = 1;

    transport.on("error", this.disconnect);
    transport.on("disconnect", this.disconnect);
    transport.on("message", this._onMessage);
    transport.on("drain", this._onDrain);

    // Handshake with the other end
    this.send(["ready", this._onReady]);

    // Start timeout and route events to callback
    this.on("connect", onConnect);
    this.on("disconnect", onDisconnect);
    this.on("error", onError);
    var timeout;
    if (this.connectionTimeout) {
        timeout = setTimeout(onTimeout, this.connectionTimeout);
    }

    var self = this;
    function onConnect(api) {
        reset();
        if (callback) callback(null, api);
    }
    function onDisconnect(err) {
        onError(err || new Error("EDISCONNECT: Agent disconnected"));
    }
    function onError(err) {
        reset();
        if (callback) callback(err);
        else self.emit("error", err);
    }
    function onTimeout() {
        reset();
        var err = new Error("ETIMEDOUT: Timeout while waiting for Agent agent to connect.");
        err.code = "ETIMEDOUT";
        self.emit("error", err);
    }
    // Only one event should happen, so stop event listeners on first event.
    function reset() {
        self.removeListener("connect", onConnect);
        self.removeListener("disconnect", onDisconnect);
        self.removeListener("error", onError);
        clearTimeout(timeout);
    }
};

Agent.prototype.send = function (message) {
    message = freeze(message, this._storeFunction);
    if (!this.transport) {
        console.log("smith can't send:")
        // console.dir(this)
        console.dir(message)
        console.trace()
        return
    }
    
    try { var result = this.transport.send(message); }
    catch(e) { console.error("Agent Smith Could not send message: ", e.stack, e.message); }
    
    return result;
};

Agent.prototype._onReady = function (names, env) {
    if (!Array.isArray(names)) return;
    var self = this;
    names.forEach(function (name) {
        // Ignore already set functions so that existing function references
        // stay valid.
        if (self.remoteApi.hasOwnProperty(name)) return;
        self.remoteApi[name] = function () {
            // When disconnected we can't forward the call.
            if (!self.transport) {
                var callback = arguments[arguments.length - 1];
                if (typeof callback === "function") {
                    setTimeout(function(){
                        var err = new Error("ENOTCONNECTED: Agent is offline, try again later");
                        err.code = "ENOTCONNECTED";
                        callback(err);
                    }, 10);
                }
                return;
            }
            var args = [name];
            args.push.apply(args, arguments);
            return self.send(args);
        };
    });
    this.remoteEnv = env;
    this._emitConnect();
};

Agent.prototype._emitConnect = function () {
    this.emit("connect", this.remoteApi);
};

// Disconnect resets the state of the Agent, flushes callbacks and emits a
// "disconnect" event with optional error object.
Agent.prototype.disconnect = function (err) {
    if (!this.transport) {
        // Agent is already disconnected
        return;
    }

    var cerr = err;
    if (!cerr) {
        cerr = new Error("EDISCONNECT: Agent disconnected");
        cerr.code = "EDISCONNECT";
    }

    // Flush any callbacks
    if (this.callbacks) {
        var callbacks = this.callbacks;
        this.callbacks = undefined;
        forEach(callbacks, function (callback) {
            callback(cerr);
        });
    }
    
    // Disconnect from transport
    if (this.transport) {
        this.transport.removeListener("error", this.disconnect);
        this.transport.removeListener("disconnect", this.disconnect);
        this.transport.removeListener("message", this._onMessage);
        this.transport.removeListener("drain", this._onDrain);
        this.transport.disconnect();
        this.transport = undefined;
    }

    this.emit("disconnect", err);
    this.nextKey = undefined;
};

// Forward drain events
Agent.prototype._onDrain = function () {
    this.emit("drain");
};

// Route incoming messages to the right functions
Agent.prototype._onMessage = function (message) {

    if (!(Array.isArray(message) && message.length)) {
        return this.emit("error", new Error("Message should be an array"));
    }
    
    message = liven(message, this._getFunction);
    var id = message[0];
    
    var fn;
    if (id === "ready") {
        var keys = Object.keys(this.api);
        var env = typeof process !== "undefined" && process.env;
        fn = function (callback) {
            callback(keys, env);
        };
    }
    else {
        fn = typeof id === "string" ? this.api[id] : this.callbacks[id];
        if (!fn) console.log("MISSING ID", id);
    }
    if (typeof fn !== "function") {
        return this.emit("error",  new Error("Should be function"));
    }
    fn.apply(this, message.slice(1));
};

// Create a proxy function that calls fn key on the Agent side.
// This is for when a Agent passes a callback to a local function.
Agent.prototype._getFunction = function (key) {
    // var transport = this.transport;
    var _self = this;
    return function () {
        // Call a Agent function using [key, args...]
        var args = [key];
        // Push is actually fast http://jsperf.com/array-push-vs-concat-vs-unshift
        args.push.apply(args, arguments);
        return _self.send(args);
    };
};

// This is for when we call a Agent function and pass in a callback
Agent.prototype._storeFunction = function (fn) {
    if (!this.callbacks)
        return new Error("Agent disconnected");
        
    var key = this.nextKey;
    while (this.callbacks.hasOwnProperty(key)) {
        key = (key + 1) >> 0;
        if (key === this.nextKey) {
            throw new Error("Ran out of keys!!");
        }
    }
    this.nextKey = (key + 1) >> 0;

    var callbacks = this.callbacks;
    var self = this;
    // Wrap is a self cleaning function and store in the index
    callbacks[key] = function () {
        delete callbacks[key];
        self.nextKey = key;
        return fn.apply(this, arguments);
    };
    return key;
};

// Convert a js object into a serializable object when functions are
// encountered, the storeFunction callback is called for each one.
// storeFunction takes in a function and returns a unique id number. Cycles
// are stored as object with a single $ key and an array of strigs as the
// path. Functions are stored as objects with a single $ key and id as value.
// props. properties starting with "$" have an extra $ prepended.
function freeze(value, storeFunction) {
    var seen = [];
    var paths = [];
    function find(value, path) {
        // find the type of the value
        var type = getType(value);
        // pass primitives through as-is
        if (type !== "function" && type !== "object" && type !== "array" && type !== "date") {
            return value;
        }

        // Look for duplicates
        var index = seen.indexOf(value);
        if (index >= 0) {
            return { "$": paths[index] };
        }
        // If not seen, put it in the registry
        index = seen.length;
        seen[index] = value;
        paths[index] = path;

        var o;
        // Look for functions
        if (type === "function") {
            o = storeFunction(value);
        }

        if (type === "date") {
            o = {d:value.getTime()};
        }

        if (o) return {$:o};

        // Recurse on objects and arrays
        return map(value, function (sub, key) {
            return find(sub, path.concat([key]));
        }, null, function (key) {
          return key[0] === "$" ? "$" + key : key;
        });
    }
    return find(value, []);
}

// Converts flat objects into live objects.  Cycles are re-connected and
// functions are inserted. The getFunction callback is called whenever a
// frozen function is encountered. It expects an ID and returns the function
function liven(message, getFunction) {
    function find(value, parent, key) {
        // find the type of the value
        var type = getType(value);

        // Unescape $$+ escaped keys
        if (key[0] === "$") key = key.substr(1);

        // pass primitives through as-is
        if (type !== "function" && type !== "object" && type !== "array") {
            parent[key] = value;
            return value;
        }

        // Load Specials
        if (value.hasOwnProperty("$")) {
            var special = value.$;
            // Load backreferences
            if (Array.isArray(special)) {
              parent[key] = get(obj.root, special);
              return parent[key];
            }
            if (typeof special === "object") {
                parent[key] = new Date(special.d);
                return parent[key];
            }
            // Load functions
            parent[key] = getFunction(special);
            return  parent[key];
        }

        // Recurse on objects and arrays
        var o = Array.isArray(value) ? [] : {};
        parent[key] = o;
        forEach(value, function (sub, key) {
            find(sub, o, key);
        });
        return obj;
    }
    var obj = {};
    find(message, obj, "root");
    return obj.root;
}

////////////////////////////////////////////////////////////////////////////////

// Typeof is broken in javascript, add support for null and buffer types
function getType(value) {
    if (value === null) {
        return "null";
    }
    if (Array.isArray(value)) {
        return "array";
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
        return "buffer";
    }
    // TODO: find a way to work with Date instances from other contexts.
    if (value instanceof Date) {
        return "date";
    }
    return typeof value;
}

// Traverse an object to get a value at a path
function get(root, path) {
    var target = root;
    for (var i = 0, l = path.length; i < l; i++) {
        target = target[path[i]];
    }
    return target;
}

// forEach that works on both arrays and objects
function forEach(value, callback, thisp) {
    if (typeof value.forEach === "function") {
        return value.forEach.call(value, callback, thisp);
    }
    var keys = Object.keys(value);
    for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        callback.call(thisp, value[key], key, value);
    }
}

// map that works on both arrays and objects
function map(value, callback, thisp, keyMap) {
    if (typeof value.map === "function") {
        return value.map.call(value, callback, thisp);
    }
    var obj = {};
    var keys = Object.keys(value);
    for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        obj[keyMap ? keyMap(key) : key] = callback.call(thisp, value[key], key, value);
    }
    return obj;
}


exports.WebSocketTransport = WebSocketTransport;
inherits(WebSocketTransport, Transport);

// "message" - event emitted when we get a message from the other side.
// "disconnect" - the transport was disconnected
// "error" - event emitted for stream error or disconnect
// "drain" - drain event from output stream
function WebSocketTransport(socket) {
    this.socket = socket;
    var self = this;

    socket.on("message", onMessage);
    socket.on("close", onDisconnect);
    socket.on("error", onError);
    function onError(err) {
        self.emit("error", err);
    }
    function onMessage(data) {
        var message;
        try { message = msgpack.decode(data); }
        catch (err) { return onError(err); }
        exports.debug && console.log(process.pid + " <- " + require('util').inspect(message, false, 2, true));
        self.emit("message", message);
    }
    function onDisconnect() {
        // Remove all the listeners we added and destroy the socket
        socket.removeListener("message", onMessage);
        socket.removeListener("close", onDisconnect);
        self.emit("disconnect");
    }
    this.disconnect = onDisconnect;
    // TODO: Implement "drain" event, pause(), and resume() properly.
    // function onDrain() {
    //   self.emit("drain");
    // }
}

WebSocketTransport.prototype.send = function (message) {
    // Uncomment to debug protocol
    exports.debug && console.log(process.pid + " -> " + require('util').inspect(message, false, 2, true));
    var data;
    try { data = msgpack.encode(message); }
    catch (err) { return this.emit("error", err); }
    this.socket.send(data, {binary: true});
};

exports.BrowserTransport = BrowserTransport;
inherits(BrowserTransport, Transport);

function BrowserTransport(websocket) {
    this.websocket = websocket;
    var self = this;

    websocket.binaryType = 'arraybuffer';
    websocket.onmessage = function (evt) {
        var message;
        try { message = msgpack.decode(evt.data); }
        catch (err) { return onError(err); }
        exports.debug && console.log("<-", message);
        self.emit("message", message);
    };

    websocket.onclose = function (evt) {
    };

    websocket.onerror = function (evt) {
        onError(new Error(evt.data));
    };

    function onError(err) {
        self.emit("error", err);
    }

    function onDisconnect() {
        // Remove all the listeners we added and destroy the socket
        delete websocket.onmessage;
        delete websocket.onclose;
        self.emit("disconnect");
    }
    this.disconnect = onDisconnect;
}

BrowserTransport.prototype.send = function (message) {
    // Uncomment to debug protocol
    exports.debug && console.log("->", message);
    var data;
    try { data = msgpack.encode(message); }
    catch (err) { return this.emit("error", err); }
    this.websocket.send(data);
};

exports.EngineIoTransport = EngineIoTransport;
inherits(EngineIoTransport, Transport);
function EngineIoTransport(socket) {
  var self = this;
  this.socket = socket;
  
  // Route errors from socket to transport.
  function onError(err) {
    self.emit("error", err);
  }
  
  // Parse and route messages from socket to transport.
  function onMessage(message) {
    if (Array.isArray(message)) {
      if (exports.debug) {
        console.log("<-", message);
      }
      self.emit("message", message);
    }
    else {
      self.emit("legacy", message);
    }
  }
  
  // Route close events as disconnect events
  function onClose(reason) {
    self.emit("disconnect", reason);
    cleanup();
  }
  
  function onDrain() {
    self.emit("drain");
  }
  
  function onDisconnect(err) {
    self.emit("disconnect", err);
    cleanup();
  }
  
  socket.on("error", onError);
  socket.on("message", onMessage);
  socket.on("close", onClose);
  socket.on("drain", onDrain);
  socket.on("disconnect", onDisconnect);

  this.disconnect = function () {
    socket.close();
  };
  
  function cleanup() {
    socket.removeListener("error", onError);
    socket.removeListener("message", onMessage);
    socket.removeListener("close", onClose);
    socket.removeListener("drain", onDrain);
    socket.removeListener("disconnect", onDisconnect);
  }

  // Encode and route send calls to socket.
  this.send = function (message) {
    if (exports.debug && Array.isArray(message)) {
      console.log("->", message);
    }
    return socket.send(message);
  };

}


return exports;
});

});


define('msgpack-js', function (module, exports) {

exports.encode = function (value) {
  var buffer = new Buffer(sizeof(value));
  encode(value, buffer, 0);
  return buffer;
};

exports.decode = decode;

// http://wiki.msgpack.org/display/MSGPACK/Format+specification
// I've extended the protocol to have two new types that were previously reserved.
//   buffer 16  11011000  0xd8
//   buffer 32  11011001  0xd9
// These work just like raw16 and raw32 except they are node buffers instead of strings.
//
// Also I've added a type for `undefined`
//   undefined  11000100  0xc4

function Decoder(buffer, offset) {
  this.offset = offset || 0;
  this.buffer = buffer;
}
Decoder.prototype.map = function (length) {
  var value = {};
  for (var i = 0; i < length; i++) {
    var key = this.parse();
    value[key] = this.parse();
  }
  return value;
};
Decoder.prototype.buf = function (length) {
  var value = this.buffer.slice(this.offset, this.offset + length);
  this.offset += length;
  return value;
};
Decoder.prototype.raw = function (length) {
  var value = this.buffer.toString('utf8', this.offset, this.offset + length);
  this.offset += length;
  return value;
};
Decoder.prototype.array = function (length) {
  var value = new Array(length);
  for (var i = 0; i < length; i++) {
    value[i] = this.parse();
  }
  return value;
};
Decoder.prototype.parse = function () {
  var type = this.buffer[this.offset];
  var value, length;
  // FixRaw
  if ((type & 0xe0) === 0xa0) {
    length = type & 0x1f;
    this.offset++;
    return this.raw(length);
  }
  // FixMap
  if ((type & 0xf0) === 0x80) {
    length = type & 0x0f;
    this.offset++;
    return this.map(length);
  }
  // FixArray
  if ((type & 0xf0) === 0x90) {
    length = type & 0x0f;
    this.offset++;
    return this.array(length);
  }
  // Positive FixNum
  if ((type & 0x80) === 0x00) {
    this.offset++;
    return type;
  }
  // Negative Fixnum
  if ((type & 0xe0) === 0xe0) {
    value = this.buffer.readInt8(this.offset);
    this.offset++;
    return value;
  }
  switch (type) {
  // raw 16
  case 0xda:
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.raw(length);
  // raw 32
  case 0xdb:
    length = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return this.raw(length);
  // nil
  case 0xc0:
    this.offset++;
    return null;
  // false
  case 0xc2:
    this.offset++;
    return false;
  // true
  case 0xc3:
    this.offset++;
    return true;
  // undefined
  case 0xc4:
    this.offset++;
    return undefined;
  // uint8
  case 0xcc:
    value = this.buffer[this.offset + 1];
    this.offset += 2;
    return value;
  // uint 16
  case 0xcd:
    value = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return value;
  // uint 32
  case 0xce:
    value = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return value;
  // uint64
  case 0xcf:
    value = this.buffer.readUInt64BE(this.offset + 1);
    this.offset += 9;
    return value;
  // int 8
  case 0xd0:
    value = this.buffer.readInt8(this.offset + 1);
    this.offset += 2;
    return value;
  // int 16
  case 0xd1:
    value = this.buffer.readInt16BE(this.offset + 1);
    this.offset += 3;
    return value;
  // int 32
  case 0xd2:
    value = this.buffer.readInt32BE(this.offset + 1);
    this.offset += 5;
    return value;
  // int 64
  case 0xd3:
    value = this.buffer.readInt64BE(this.offset + 1);
    this.offset += 9;
    return value;
  // map 16
  case 0xde:
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.map(length);
  // map 32
  case 0xdf:
    length = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return this.map(length);
  // array 16
  case 0xdc:
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.array(length);
  // array 32
  case 0xdd:
    length = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return this.array(length);
  // buffer 16
  case 0xd8:
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.buf(length);
  // buffer 32
  case 0xd9:
    length = this.buffer.readUInt32BE(this.offset + 1);
    this.offset += 5;
    return this.buf(length);
  // float
  case 0xca:
    value = this.buffer.readFloatBE(this.offset + 1);
    this.offset += 5;
    return value;
  // double
  case 0xcb:
    value = this.buffer.readDoubleBE(this.offset + 1);
    this.offset += 9;
    return value;
  }
  throw new Error("Unknown type 0x" + type.toString(16));
};
function decode(buffer) {
  var decoder = new Decoder(buffer);
  var value = decoder.parse();
  if (decoder.offset !== buffer.length) throw new Error((buffer.length - decoder.offset) + " trailing bytes");
  return value;
}

function encode(value, buffer, offset) {
  var type = typeof value;

  // Strings Bytes
  if (type === "string") {
    var length = Buffer.byteLength(value);
    // fix raw
    if (length < 0x20) {
      buffer[offset] = length | 0xa0;
      length && buffer.write(value, offset + 1);
      return 1 + length;
    }
    // raw 16
    if (length < 0x10000) {
      buffer[offset] = 0xda;
      buffer.writeUInt16BE(length, offset + 1);
      buffer.write(value, offset + 3);
      return 3 + length;
    }
    // raw 32
    if (length < 0x100000000) {
      buffer[offset] = 0xdb;
      buffer.writeUInt32BE(length, offset + 1);
      buffer.write(value, offset + 5);
      return 5 + length;
    }
  }

  if (Buffer.isBuffer(value)) {
    var length = value.length;
    // buffer 16
    if (length < 0x10000) {
      buffer[offset] = 0xd8;
      buffer.writeUInt16BE(length, offset + 1);
      value.copy(buffer, offset + 3);
      return 3 + length;
    }
    // buffer 32
    if (length < 0x100000000) {
      buffer[offset] = 0xd9;
      buffer.writeUInt32BE(length, offset + 1);
      value.copy(buffer, offset + 5);
      return 5 + length;
    }
  }

  if (type === "number") {
    // Floating Point
    if ((value << 0) !== value) {
      buffer[offset] =  0xcb;
      buffer.writeDoubleBE(value, offset + 1);
      return 9;
    }

    // Integers
    if (value >=0) {
      // positive fixnum
      if (value < 0x80) {
        buffer[offset] = value;
        return 1;
      }
      // uint 8
      if (value < 0x100) {
        buffer[offset] = 0xcc;
        buffer[offset + 1] = value;
        return 2;
      }
      // uint 16
      if (value < 0x10000) {
        buffer[offset] = 0xcd;
        buffer.writeUInt16BE(value, offset + 1);
        return 3;
      }
      // uint 32
      if (value < 0x100000000) {
        buffer[offset] = 0xce;
        buffer.writeUInt32BE(value, offset + 1);
        return 5;
      }
      // uint 64
      if (value < 0x10000000000000000) {
        buffer[offset] = 0xcf;
        buffer.writeUInt64BE(value, offset + 1);
        return 9;
      }
      throw new Error("Number too big 0x" + value.toString(16));
    }
    // negative fixnum
    if (value >= -0x20) {
      buffer.writeInt8(value, offset);
      return 1;
    }
    // int 8
    if (value >= -0x80) {
      buffer[offset] = 0xd0;
      buffer.writeInt8(value, offset + 1);
      return 2;
    }
    // int 16
    if (value >= -0x8000) {
      buffer[offset] = 0xd1;
      buffer.writeInt16BE(value, offset + 1);
      return 3;
    }
    // int 32
    if (value >= -0x80000000) {
      buffer[offset] = 0xd2;
      buffer.writeInt32BE(value, offset + 1);
      return 5;
    }
    // int 64
    if (value >= -0x8000000000000000) {
      buffer[offset] = 0xd3;
      buffer.writeInt64BE(value, offset + 1);
      return 9;
    }
    throw new Error("Number too small -0x" + value.toString(16).substr(1));
  }

  // undefined
  if (type === "undefined") {
    buffer[offset] = 0xc4;
    return 1;
  }

  // null
  if (value === null) {
    buffer[offset] = 0xc0;
    return 1;
  }

  // Boolean
  if (type === "boolean") {
    buffer[offset] = value ? 0xc3 : 0xc2;
    return 1;
  }

  // Container Types
  if (type === "object") {
    var length, size = 0;
    var isArray = Array.isArray(value);

    if (isArray) {
      length = value.length;
    }
    else {
      var keys = Object.keys(value);
      length = keys.length;
    }

    var size;
    if (length < 0x10) {
      buffer[offset] = length | (isArray ? 0x90 : 0x80);
      size = 1;
    }
    else if (length < 0x10000) {
      buffer[offset] = isArray ? 0xdc : 0xde;
      buffer.writeUInt16BE(length, offset + 1);
      size = 3;
    }
    else if (length < 0x100000000) {
      buffer[offset] = isArray ? 0xdd : 0xdf;
      buffer.writeUInt32BE(length, offset + 1);
      size = 5;
    }

    if (isArray) {
      for (var i = 0; i < length; i++) {
        size += encode(value[i], buffer, offset + size);
      }
    }
    else {
      for (var i = 0; i < length; i++) {
        var key = keys[i];
        size += encode(key, buffer, offset + size);
        size += encode(value[key], buffer, offset + size);
      }
    }

    return size;
  }
  throw new Error("Unknown type " + type);
}

function sizeof(value) {
  var type = typeof value;

  // Raw Bytes
  if (type === "string") {
    var length = Buffer.byteLength(value);
    if (length < 0x20) {
      return 1 + length;
    }
    if (length < 0x10000) {
      return 3 + length;
    }
    if (length < 0x100000000) {
      return 5 + length;
    }
  }

  if (Buffer.isBuffer(value)) {
    var length = value.length;
    if (length < 0x10000) {
      return 3 + length;
    }
    if (length < 0x100000000) {
      return 5 + length;
    }
  }

  if (type === "number") {
    // Floating Point
    // double
    if (value << 0 !== value) return 9;

    // Integers
    if (value >=0) {
      // positive fixnum
      if (value < 0x80) return 1;
      // uint 8
      if (value < 0x100) return 2;
      // uint 16
      if (value < 0x10000) return 3;
      // uint 32
      if (value < 0x100000000) return 5;
      // uint 64
      if (value < 0x10000000000000000) return 9;
      throw new Error("Number too big 0x" + value.toString(16));
    }
    // negative fixnum
    if (value >= -0x20) return 1;
    // int 8
    if (value >= -0x80) return 2;
    // int 16
    if (value >= -0x8000) return 3;
    // int 32
    if (value >= -0x80000000) return 5;
    // int 64
    if (value >= -0x8000000000000000) return 9;
    throw new Error("Number too small -0x" + value.toString(16).substr(1));
  }

  // Boolean, null, undefined
  if (type === "boolean" || type === "undefined" || value === null) return 1;

  // Container Types
  if (type === "object") {
    var length, size = 0;
    if (Array.isArray(value)) {
      length = value.length;
      for (var i = 0; i < length; i++) {
        size += sizeof(value[i]);
      }
    }
    else {
      var keys = Object.keys(value);
      length = keys.length;
      for (var i = 0; i < length; i++) {
        var key = keys[i];
        size += sizeof(key) + sizeof(value[key]);
      }
    }
    if (length < 0x10) {
      return 1 + size;
    }
    if (length < 0x10000) {
      return 3 + size;
    }
    if (length < 0x100000000) {
      return 5 + size;
    }
    throw new Error("Array or object too long 0x" + length.toString(16));
  }
  throw new Error("Unknown type " + type);
}



});


define('vfs-local', function (module, exports) {

var fs = require("fs");
var net = require("net");
var childProcess = require("child_process");
var constants = require("constants");
var join = require("path").join;
var pathResolve = require("path").resolve;
var pathNormalize = require("path").normalize;
var pathBasename = require("path").basename;
var dirname = require("path").dirname;
var basename = require("path").basename;
var Stream = require("stream").Stream;
var getMime = (function(simpleMime) {
    // workaround for a bug in simple-mime
    return function(path) {
        var mime = simpleMime(path);
        if (typeof mime != "string")
            return "application/octet-stream"
        return mime;
    }
})(require("simple-mime")());
var vm = require("vm");
var exists = fs.exists || require("path").exists;
var crypto = require("crypto");
var os = require("os");
var pathSep = require("path").sep;
var transformPath;
var isWin = pathSep == "\\";

// node 0.6 does not have domain support
var domain;
try {
    domain = require("domain");
} catch(e) {}

//////////////////// windows support ///////////////////////////////////////////
if (isWin) {
    var _pathNormalize = pathNormalize;
    var _join = join;
    var _pathResolve = pathResolve;
    pathNormalize = function(p) {
        return _pathNormalize(p).replace(/[\\]/g, "/");
    };
    join = function() {
        return _join.apply(null, arguments).replace(/[\\]/g, "/");
    };
    transformPath = function(path) {
        if (path[0] == "/") {
            var m = /^\/+(\w):[\/\\]*/.exec(path);
            if (m) {
                var device = m ? m[1] : "";
                path = device + ":/" + path.substr(m[0].length).replace(/[:*?"<>|]/g, "_");
            }
        }
        return path;
    };
    pathResolve = function(path, link) {
        path = _pathResolve(path, link);
        if (path[0] !== "/") {
            path = "/" + path.replace(/[\\]/g, "/");
        }
        return path;
    };
}

// For debugging only
function logToFile(message){
    fs.appendFile('/tmp/vfs.log', new Date().getTime() + " " + message + "\n", function (err) {
    
    });
}

////////////////////////////////////////////////////////////////////////////////

module.exports = function setup(fsOptions) {
    var pty;
    if (fsOptions.nodePath) {
        process.env.NODE_PATH = fsOptions.nodePath;
        require("module")._initPaths();
    }
    if (!fsOptions.nopty) {
        // on darwin trying to load binary for a wrong version crashes the process
        [(fsOptions.nodePath || process.env.HOME + "/.c9/node_modules") + "/pty.js",
            "pty.js", "pty.nw.js"].some(function(p) {
            try {
                pty = require(p);
                return true;
            } catch(e) {
                console.warn(e, p);
            }
        });
        if (!pty)
            console.warn("unable to initialize pty.js:");
    }
    if (!pty) {
        pty = function(command, options, callback) {
            console.log("PTY is not supported.");
        };
        pty.spawn = pty;
    }

    var TMUX       = fsOptions.tmuxBin || "tmux";
    var BASH       = fsOptions.bashBin || process.env.C9_BASH_BIN || (isWin ? "bash.exe" : "bash");
    var METAPATH   = fsOptions.metapath;
    var WSMETAPATH = fsOptions.wsmetapath;
    var TESTING    = fsOptions.testing;
    var TMUXNAME   = "cloud9";
    var noTmux;
    var tmuxWarned;

    // Check and configure options
    var root = fsOptions.root;
    if (!root) throw new Error("root is a required option");
    root = pathNormalize(root);
    
    if (pathSep == "/" && root[0] !== "/") throw new Error("root path must start in /");
    if (root[root.length - 1] !== "/") root += "/";
    
    var base = root.substr(0, root.length - 1);
    
    // Fetch umask
    var umask = 022;
    _execFile(BASH, ["-c", "umask"], function(error, stdout, stderr) {
        if (!error && !stderr && stdout) 
            umask = parseInt(stdout, 8);
    });
    
    // Fetch tmux version
    _execFile(TMUX, ["-V"], function(err, stdout) {
        if (err) stdout = "tmux 1.9";
        noTmux = err && err.code === "ENOENT";
        TMUXNAME = "cloud9" + parseFloat(stdout.replace(/tmux([-\d.]*) /, ""), 10);
    });
    
    if (fsOptions.hasOwnProperty('defaultEnv')) {
        fsOptions.defaultEnv.__proto__ = process.env;
    } else {
        fsOptions.defaultEnv = process.env;
    }
    
    // Fetch environment variables from the login shell
    var waitForEnv = null;
    if (!isWin) {
        waitForEnv = [];
        _execFile(BASH, ["-lc", "printenv -0"], function(error, stdout, stderr) {
            var pending = waitForEnv;
            waitForEnv = null;
            if (!error && !stderr && stdout) {
                var env = fsOptions.defaultEnv;
                stdout.split("\x00").forEach(function(entry) {
                    var i = entry.indexOf("=");
                    if (i != -1)
                        env[entry.slice(0, i)] = entry.slice(i + 1);
                });
            }
            pending.forEach(function(x) { x(); });
        });
    }
    
    // Storage for extension APIs
    var apis = {};
    // Storage for event handlers
    var handlers = {};
    
    var fileWatchers = {};

    // Export the API
    var vfs = wrapDomain({
        fsOptions: fsOptions,
        
        // File management
        resolve: resolve,
        stat: stat,
        readfile: readfile,
        readdir: readdir,
        mkfile: mkfile,
        mkdir: mkdir,
        mkdirP: mkdirP,
        appendfile: appendfile,
        rmfile: rmfile,
        rmdir: rmdir,
        rename: rename,
        copy: copy,
        symlink: symlink,
        chmod: chmod,

        // Set/Retrieve Metadata
        metadata: metadata,
        getMetadata: getMetadata,

        // Wrapper around fs.watch or fs.watchFile
        watch: watch,

        // Network connection
        connect: connect,

        // Process Management
        spawn: spawn,
        pty: ptyspawn,
        tmux: process.platform == "win32" ? bashspawn : tmuxspawn,
        execFile: execFile,
        killtree: killtree,

        // Basic async event emitter style API
        on: on,
        off: off,
        emit: emit,

        // Extending the API
        extend: extend,
        unextend: unextend,
        use: use,
        
        workspaceDir: fsOptions.projectDir
    });
    
    function wrapDomain(api) {
        if (!domain)
            return api;
            
        for(var func in api) {
            if (typeof api[func] !== "function")
                continue;
                
            (function(func) {
                var call = api[func];
                api[func] = function() {
                    var args = Array.prototype.slice.apply(arguments);
                    var d = domain.create();
                    d.on("error", function(e) {
                        console.error("VFS Exception in function '" + func + "':\n", (e.stack || e));
                        vfs.emit("error", {
                            message: e.message,
                            func: func,
                            stack: e.stack + "",
                            node: process.version
                        });
                        console.log("Scheduling process exit");
                        setTimeout(function() {
                            console.log("Exiting after uncaught exception in '" + func + "':\n", (e.stack || e))
                            process.exit(1);
                        }, 2000);
                    });
                    d.run(function() {
                        call.apply(api, args);
                    });
                };
            })(func);
        }
        return api;
    }

////////////////////////////////////////////////////////////////////////////////
    if (isWin) {
        var readSpecialDir = function(path, callback) {
            if (path == "/") {
                execFile("cmd", { args: ["/c", "wmic logicaldisk get deviceid"] }, function(err, result) {
                    if (result && result.stdout) {
                        var drives = result.stdout.match(/ *\w:/g).map(function(x){return x.trim()});
                        var meta = {};
                        var stat = {
                            isFile: function() {return false},
                            size: 0,
                            mtime: Date.now()
                        };
                        // meta.notModified = true;
                        meta.etag = calcEtag(stat);
                        calcEtag(stat);
                        meta.stream = new Stream();
                        meta.stream.readable = true;
                        callback(null, meta);
                        drives.forEach(function(d) {
                            meta.stream.emit("data", {
                                mime: "drive/directory",
                                mtime: stat.mtime,
                                name: d,
                                size: 0
                            });
                        });
                        meta.stream.emit("end");
                    }
                });
                return true;
            }
        };
        var isSpecialPath = function(path) {
            return path == "/";
        };
    }
////////////////////////////////////////////////////////////////////////////////

    function _execFile() {
        var callback = arguments[arguments.length-1];
        try {
            return childProcess.execFile.apply(childProcess, arguments);
        } catch(e) {
            callback(e);
        }
    }

    // Realpath a file and check for access
    // callback(err, path)
    function resolvePath(path, options, callback) {
        if (!callback) {
            callback = options;
            options = {};
        }
        
        var alreadyRooted = options.alreadyRooted;
        var checkSymlinks = options.checkSymlinks;
        var sandbox = options.sandbox;
        
        if (checkSymlinks === undefined)
            checkSymlinks = true;
            
        if (!alreadyRooted) {
            if (sandbox)
                path = join(sandbox, path);
                
            path = join(root, path);
        }
        
        if (!options.nocheck) {
            var localRoot = sandbox ? join(root, sandbox) : root;
            var base = root.substr(0, localRoot.length - 1);
            var testPath = path.substr(0, localRoot.length);
            
            if (isWin) {
                testPath = testPath.toLowerCase();
                base = base.toLowerCase();
                localRoot = localRoot.toLowerCase();
            }
            
            if (!(path === base || testPath === localRoot)) {
                var isError = true;
                
                if (isError) {
                    var err = new Error("EACCES: '" + path + "' not in '" + localRoot + "'");
                    err.code = "EACCES";
                    return callback(err);
                }
            }
        }
        
        if (transformPath)
            path = transformPath(path);
        
        if ((checkSymlinks && fsOptions.checkSymlinks || checkSymlinks == 2) && !alreadyRooted)
            fs.realpath(path, callback);
        else
            callback(null, path);
    }
    
    // A wrapper around fs.open that enforces permissions and gives extra data in
    // the callback. (err, path, fd, stat)
    function open(path, flags, mode, options, callback) {
        resolvePath(path, options, function (err, path) {
            if (err) return callback(err);
            fs.open(path, flags, mode, function (err, fd) {
                if (err) return callback(err);
                fs.fstat(fd, function (err, stat) {
                    if (err) return callback(err);
                    callback(null, path, fd, stat);
                });
            });
        });
    }

    // This helper function doesn't follow node conventions in the callback,
    // there is no err, only entry.
    function createStatEntry(file, fullpath, callback, _loop) {
        fs.lstat(fullpath, function (err, stat) {
            var entry = {
                name: file
            };

            if (err) {
                entry.err = err;
                return callback(entry);
            } else {
                entry.size = stat.size;
                entry.mtime = stat.mtime.valueOf();
                entry.ctime = stat.ctime.valueOf();

                if (stat.isDirectory()) {
                    entry.mime = "inode/directory";
                } else if (stat.isBlockDevice()) entry.mime = "inode/blockdevice";
                else if (stat.isCharacterDevice()) entry.mime = "inode/chardevice";
                else if (stat.isSymbolicLink()) entry.mime = "inode/symlink";
                else if (stat.isFIFO()) entry.mime = "inode/fifo";
                else if (stat.isSocket()) entry.mime = "inode/socket";
                else {
                    entry.mime = getMime(fullpath);
                }

                if (!stat.isSymbolicLink()) {
                    return callback(entry);
                }
                fs.readlink(fullpath, function (err, link) {
                    if (err) {
                        entry.linkErr = err.stack;
                        return callback(entry);
                    }
                    var fullLinkPath = pathResolve(dirname(fullpath), link);
                    if (!_loop) {
                        _loop = {fullLinkPath: fullpath, max: 100};
                    }
                    if (fullLinkPath.toLowerCase() == _loop.fullLinkPath.toLowerCase() || _loop.max --< 0) {
                        entry.linkErr = "ELOOP: recursive symlink";
                        return callback(entry);
                    }
                    entry.link = link;
                    resolvePath(fullLinkPath, {alreadyRooted: true}, function (err, newpath) {
                        if (err) {
                            entry.linkErr = err;
                            return callback(entry);
                        }
                        createStatEntry(basename(newpath), newpath, function (linkStat) {
                            entry.linkStat = linkStat;
                            linkStat.fullPath = newpath.substr(base.length) || "/";
                            return callback(entry);
                        }, _loop);
                    });
                });
            }
        });
    }

    // Common logic used by rmdir and rmfile
    function remove(path, fn, options, callback) {
        var meta = {};
        resolvePath(path, options, function (err, realpath) {
            if (err) return callback(err);
            fn(realpath, function done(err) {
                if (err) {
                    if (err.code == "ENOENT") {
                        return fs.exists(realpath, function(exists) {
                            if (exists) err.code = "EACCES";
                            callback(err);
                        });
                    } else {
                        return callback(err);
                    }
                }
                
                // Remove metadata
                resolvePath(WSMETAPATH + path, options, function (err, realpath) {
                    if (err) return callback(null, meta);
                    
                    fn(realpath, function(){
                        return callback(null, meta);
                    });
                });
            });
        });
    }

////////////////////////////////////////////////////////////////////////////////

    function resolve(path, options, callback) {
        resolvePath(path, options, function (err, path) {
            if (err) return callback(err);
            callback(null, { path: path });
        });
    }

    function stat(path, options, callback) {
        // Make sure the parent directory is accessable
        resolvePath(dirname(path), options, function (err, dir) {
            if (err) return callback(err);
            var file = basename(path);
            path = join(dir, file);
            createStatEntry(file, path, function (entry) {
                if (entry.err) {
                    return callback(entry.err);
                }
                callback(null, entry);
            });
        });
    }
    
    function metadata(path, options, callback) {
        if (path.charAt(0) == "~")
            path = join(process.env.HOME, path.substr(1));
        
        var dirpath = (path.substr(0,5) == "/_/_/" 
            ? METAPATH + dirname(path.substr(4))
            : WSMETAPATH + "/" + dirname(path));
            
        resolvePath(dirpath, options, function (err, dir) {
            if (err) return callback(err);
            
            var file = basename(path);
            path = join(dir, file);
            if (pathSep === "\\")
                dir = dir.replace(/\\/g, "/");
                
            execFile("mkdir", { args: ["-p", dir] }, function(err){
                if (err) return callback(err);
                fs.writeFile(path, JSON.stringify(options.metadata), {}, function(err){
                    if (err) return callback(err);
                    callback(null, {});
                });
            });
        });
    }

    function getMetadata(path, options, callback){
        if (path.charAt(0) == "~")
            path = join(process.env.HOME, path.substr(1));
        
        var metaPath = join(WSMETAPATH, path);
        
        resolvePath(metaPath, options, function (err, path) {
            if (err) return callback(err);
            fs.readFile(path, callback);
        });
    }

    function readfile(path, options, callback) {
        var meta = {};
        var originalPath = path;

        open(path, "r", 0666 & ~umask, options, function (err, path, fd, stat) {
            if (err) return callback(err);
            if (stat.isDirectory()) {
                fs.close(fd);
                err = new Error("EISDIR: Requested resource is a directory");
                err.code = "EISDIR";
                return callback(err);
            }

            // Basic file info
            meta.mime = getMime(path);
            meta.size = stat.size;
            meta.etag = calcEtag(stat);

            // ETag support
            if ((TESTING || stat.mtime % 1000) && options.etag === meta.etag) {
                meta.notModified = true;
                fs.close(fd);
                return callback(null, meta);
            }

            // Range support
            if (options.hasOwnProperty('range') && !(options.range.etag && options.range.etag !== meta.etag)) {
                var range = options.range;
                var start, end;
                if (range.hasOwnProperty("start")) {
                    start = range.start;
                    end = range.hasOwnProperty("end") ? range.end : meta.size - 1;
                }
                else {
                    if (range.hasOwnProperty("end")) {
                        start = meta.size - range.end;
                        end = meta.size - 1;
                    }
                    else {
                        meta.rangeNotSatisfiable = "Invalid Range";
                        fs.close(fd);
                        return callback(null, meta);
                    }
                }
                if (end < start || start < 0 || end >= stat.size) {
                    meta.rangeNotSatisfiable = "Range out of bounds";
                    fs.close(fd);
                    return callback(null, meta);
                }
                options.start = start;
                options.end = end;
                meta.size = end - start + 1;
                meta.partialContent = { start: start, end: end, size: stat.size };
            }
            
            var metaData;
            if (options.hasOwnProperty("metadata") && originalPath.indexOf(WSMETAPATH) == -1) {
                getMetadata(originalPath, options, function (err, data) {
                    if (err)
                        return done();
                    try {
                        meta.metadataSize = data.length;
                        meta.metadataStringLength = data.toString("utf8").length;
                        metaData = data;
                        done(true);
                    } catch (e) {
                        fs.close(fd);
                        done();
                    }
                });
            }
            else {
                done();
            }

            function done(fakeStream){
                // HEAD request support
                if (options.hasOwnProperty("head")) {
                    fs.close(fd);
                    return callback(null, meta);
                }
    
                // Read the file as a stream
                try {
                    options.fd = fd;
                    meta.stream = new fs.ReadStream(path, options);
                } catch (err) {
                    fs.close(fd);
                    return callback(err);
                }
                
                if (fakeStream) {
                    var readStream = meta.stream;
                    meta.stream = new Stream();
                    meta.stream.readable = true;
                    meta.stream.writable = true;
                    meta.stream.write = function (data) {
                      meta.stream.emit("data", data);
                      return true;
                    };
                    meta.stream.end = function (data) {
                      meta.stream.emit("end", data);
                    };
                    readStream.pipe(meta.stream, { end : false });
                    readStream.on("end", function(){
                        meta.stream.write(metaData);
                        meta.stream.end();
                    });
                    meta.stream.destroy = function () {
                        readStream.destroy();
                    };
                }
                
                callback(null, meta);
            }
        });
    }

    function readdir(path, options, callback) {
        var meta = {};
        
        resolvePath(path, options, function (err, path) {
            if (err) return callback(err);
            if (isWin && readSpecialDir) {
                if (readSpecialDir(path, callback))
                    return;
            }
            fs.stat(path, function (err, stat) {
                if (err) return callback(err);
                if (!stat.isDirectory()) {
                    err = new Error("ENOTDIR: Requested resource is not a directory");
                    err.code = "ENOTDIR";
                    return callback(err);
                }

                // ETag support
                meta.etag = calcEtag(stat);
                if ((TESTING || stat.mtime % 1000) && options.etag === meta.etag) {
                    meta.notModified = true;
                    return callback(null, meta);
                }

                fs.readdir(path, function (err, files) {
                    if (err) return callback(err);
                    if (options.head) {
                        return callback(null, meta);
                    }
                    var stream = new Stream();
                    stream.readable = true;
                    var paused;
                    stream.pause = function () {
                        if (paused === true) return;
                        paused = true;
                    };
                    stream.resume = function () {
                        if (paused === false) return;
                        paused = false;
                        getNext();
                    };
                    meta.stream = stream;
                    callback(null, meta);
                    var index = 0;
                    stream.resume();
                    function getNext() {
                        if (index === files.length) return done();
                        var file = files[index++];
                        var fullpath = join(path, file);

                        createStatEntry(file, fullpath, function onStatEntry(entry) {
                            stream.emit("data", entry);

                            if (!paused) {
                                getNext();
                            }
                        });
                    }
                    function done() {
                        stream.emit("end");
                    }
                });
            });
        });
    }
    
    // This is used for creating / overwriting files.  It always creates a new tmp
    // file and then renames to the final destination.
    // It will copy the properties of the existing file is there is one.
    function mkfile(path, options, realCallback) {
        var meta = {};
        var called;
        var callback = function (err) {
            if (called) {
                if (err) {
                    if (meta.stream) meta.stream.emit("error", err);
                    else console.error(err.stack);
                }
                else if (meta.stream) meta.stream.emit("saved");
                return;
            }
            called = true;
            return realCallback(err, meta);
        };

        if (options.stream && !options.stream.readable) {
            return callback(new TypeError("options.stream must be readable."));
        }

        // Pause the input for now since we're not ready to write quite yet
        var readable = options.stream;
        if (readable) {
            if (readable.pause) readable.pause();
            var buffer = [];
            readable.on("data", onData);
            readable.on("end", onEnd);
        }
        
        var tempPath;
        var resolvedPath = "";
        var mode = options.mode || 0666 & ~umask;

        start();

        function onData(chunk) {
            buffer.push(["data", chunk]);
        }
        function onEnd() {
            buffer.push(["end"]);
        }
        function error(err) {
            if (!options.bufferWrite)
                resume();
            if (tempPath) {
                fs.unlink(tempPath, callback.bind(null, err));
            }
            else
                return callback(err);
        }
        
        function resume() {
            if (readable) {
                // Stop buffering events and playback anything that happened.
                readable.removeListener("data", onData);
                readable.removeListener("end", onEnd);

                buffer.forEach(function (event) {
                    readable.emit.apply(readable, event);
                });
                // Resume the input stream if possible
                if (readable.resume) readable.resume();
            }
        }

        function start() {
            if (options.parents) {
                mkdirP(dirname(path), options, function(err) {
                    if (err) return error(err);
                    resolve();
                });
            }
            else {
                resolve();
            }
        }

        // Make sure the user has access to the directory and get the real path.
        function resolve() {
            options.checkSymlinks = 2;
            resolvePath(path, options, function (err, _resolvedPath) {
                if (err) {
                    if (err.code !== "ENOENT") {
                        return error(err);
                    }
                    // If checkSymlinks is on we'll get an ENOENT when creating a new file.
                    // In that case, just resolve the parent path and go from there.
                    resolvePath(dirname(path), options, function (err, dir) {
                        if (err) return error(err);
                        resolvedPath = join(dir, basename(path));
                        createTempFile();
                    });
                    return;
                }
                
                resolvedPath = _resolvedPath;
                createTempFile();
            });
        }
        
        function createTempFile() {
            // Buffer in memory when the bufferWrite option is set to true
            if (options.bufferWrite)
                return bufferAndWrite();
            
            tempPath = tmpFile(dirname(resolvedPath), "." + basename(resolvedPath) + "-", "~");
            
            fs.stat(resolvedPath, create);
            
            function create(err, stat, isParent) {
                if (err) {
                    if (err.code === "ENOENT")
                        return fs.stat(dirname(resolvedPath), function(err, stat){
                            create(err, stat, true);
                        });
                    return error(err);
                }
                
                var uid = process.getuid ? process.getuid() : 0;
                var gid = process.getgid ? process.getgid() : 0;
                
                if (stat) {
                    gid = stat.gid;
                    if (!isParent) {
                        mode = stat.mode & 0777;
                        uid = stat.uid;
                    }
                }
                
                // node 0.8.x adds a "wx" shortcut, but since it's not in 0.6.x we use the
                // longhand here.
                var flags = constants.O_CREAT | constants.O_WRONLY | constants.O_EXCL;
                fs.open(tempPath, flags, mode, options, function (err, fd) {
                    if (err)
                        return pipe();
                    
                    fchown(fd, uid, gid, function(err) {
                        fs.close(fd);
                        if (err) {
                            fs.unlink(tempPath);
                            return pipe();
                        }

                        pipe(new fs.WriteStream(tempPath, {
                            encoding: options.encoding || null,
                            mode: mode
                        }));
                    });
                });
                
                function fchown(fd, uid, gid, callback) {
                    fs.fstat(fd, function (err, stat) {
                        if (err) return callback(err);
                        
                        if (stat.uid == uid && stat.gid == gid)
                            return callback();
                        
                        fs.fchown(fd, uid, gid, callback);
                    });
                }
            }
        }
        
        function bufferAndWrite(){
            var buffers = [];
            var hadError;
            
            readable.on("data", function(chunk){
                buffers.push(new Buffer(chunk));
            });
            
            readable.on("error", function(err){
                hadError = err;
                error(err);
            });
            
            readable.on("end", function(chunk){
                if (hadError) return;
                
                writeToWatchedFile(resolvedPath, function(afterWrite) {
                    fs.writeFile(resolvedPath, Buffer.concat(buffers), function(err) {
                        afterWrite(function() {
                            if (err) return error(err);
                            callback();
                        });
                    });
                });
            });
            
            resume();
        }

        function pipe(writable) {
            var hadError;
            var swap = true;
            
            if (!writable) {
                swap = false;
                writable = new fs.WriteStream(resolvedPath, {
                    encoding: options.encoding || null,
                    mode: mode
                });
            }
            
            if (readable) {
                readable.pipe(writable);
            }
            else {
                writable.on('open', function () {
                    if (hadError) return;
                    meta.stream = writable;
                    callback();
                });
            }
            writable.on('error', function (err) {
                hadError = true;
                error(err);
            });

            // intercept the first close event and perform the swap            
            var emit = writable.emit;
            writable.emit = function(name) {
                var args = arguments;
                
                if (name !== "close")
                    return emit.apply(writable, args);
                    
                writable.emit = emit;
                    
                if (!hadError) {
                    if (!swap) {
                        emit.apply(writable, args);
                        callback();
                    }
                    else {
                        writeToWatchedFile(resolvedPath, function(afterWrite) {
                            fs.rename(tempPath, resolvedPath, function(err) {
                                afterWrite(function() {
                                    if (err) return error(err);
                                    emit.apply(writable, args);
                                    callback();
                                });
                            });
                        });
                    }
                }
                else {
                    emit.apply(writable, args);
                }
                
                return true;
            };

            resume();
        }
    }

    function mkdirP(path, options, callback) {
        resolvePath(path, { checkSymlinks: false, sandbox: options.sandbox }, function(err, dir) {
            if (err) return callback(err);
            
            exists(dir, function(exists) {
                if (exists) return callback(null, {});
                if (pathSep === "\\")
                    dir = dir.replace(/\\/g, "/");
        
                execFile("mkdir", { args: ["-p", dir] }, function(err) {
                    if (err && err.message.indexOf("exists") > -1)
                        callback({"code": "EEXIST", "message": err.message});
                    else
                        callback(null, {});
                });
            });
        });
    }

    function mkdir(path, options, callback) {
        var meta = {};
        
        if (options.parents)
            return mkdirP(path, options, callback);
            
        // Make sure the user has access to the parent directory and get the real path.
        resolvePath(dirname(path), options, function (err, dir) {
            if (err) return callback(err);
            path = join(dir, basename(path));
            fs.mkdir(path, function (err) {
                if (err) return callback(err);
                callback(null, meta);
            });
        });
    }

    function appendfile(path, options, callback) {
        resolvePath(path, options, function (err, resolvedPath) {
            if (err) return callback(err);
            fs.appendFile(resolvedPath, options.data, options, function (err) {
                if (err) return callback(err);
                callback(null, {});
            });
        });
    }

    function rmfile(path, options, callback) {
        remove(path, fs.unlink, options, callback);
    }

    function rmdir(path, options, callback) {
        if (options.recursive) {
            remove(path, function(path, callback) {
                spawn("rm", {args: ["-rf", path], stdio: 'ignore'}, function(err, child) {
                    if (err) return callback(err);
                    child.process.on("close", function(code) {
                        if (code) {
                            var err = new Error("Permission denied.");
                            err.code = "EACCES";
                            return callback(err);
                        }
                        callback();
                    });
                });
            }, options, callback);
        }
        else {
            remove(path, fs.rmdir, options, callback);
        }
    }

    function rename(path, options, callback) {
        var from, to;
        if (options.from) {
            from = options.from; to = path;
        }
        else if (options.to) {
            from = path; to = options.to;
        }
        else {
            return callback(new Error("Must specify either options.from or options.to"));
        }
        var meta = {};
        // Resolve path to source
        resolvePath(from, options, function (err, frompath) {
            if (err) return callback(err);
            // Resolve path to target dir
            resolvePath(dirname(to), options, function (err, dir) {
                if (err) return callback(err);
                var topath = join(dir, basename(to));
                
                exists(topath, function(exists) {
                    // Determine if paths are the same on a case-insensitive file system
                    // (fs.realpath and fs.stat->ino don't help here)
                    var isSamePath = /darwin|^win/.test(os.platform())
                        && frompath.toLowerCase() === topath.toLowerCase();
                    
                    if (!exists || options.overwrite || isSamePath) {
                        // Rename the file
                        renameWatchedFile(frompath, topath, function (err) {
                            if (err) {
                                if (err.code == 'ENOENT' && options.mkdirP != false) {
                                    options.mkdirP = false;
                                    return mkdirP(dir, {}, function(err) {
                                        if (err) return callback(err);
                                        rename(path, options, callback);
                                    });
                                }
                                return callback(err);
                            }
                            
                            if (options.metadata === false) {
                                return callback(null, meta);
                            }

                            // Rename metadata
                            var metaPath = WSMETAPATH;
                            rename(metaPath + from, {
                                to: metaPath + to,
                                metadata: false
                            }, function(err){
                                callback(null, meta);
                            });
                        });
                    }
                    else {
                        var err = new Error("File already exists.");
                        err.code = "EEXIST";
                        callback(err);
                    }
                });
            });
        });
    }

    function copy(path, options, callback) {
        var from, to;
        if (options.from) {
            from = options.from; to = path;
        }
        else if (options.to) {
            from = path; to = options.to;
        }
        else {
            return callback(new Error("Must specify either options.from or options.to"));
        }
        
        if (!options.overwrite) {
            resolvePath(to, options, function(err, path){
                if (err) {
                    if (err.code == "ENOENT")
                        return innerCopy(from, to);
                    
                    return callback(err);
                }
                
                fs.stat(path, function(err, stat){
                    if (!err && stat && !stat.err) {
                        // TODO: this logic should be pushed into the application code
                        var path = to.replace(/(?:\.([\d]+))?(\.[^\.\/\\]*)?$/, function(m, d, e){
                            return "." + (parseInt(d, 10)+1 || 1) + (e ? e : "");
                        });
                        
                        copy(from, {
                            to        : path, 
                            overwrite : false, 
                            recursive : options.recursive,
                            sandbox   : options.sandbox
                        }, callback);
                    }
                    else {
                        innerCopy(from, to);
                    }
                });
            });
        }
        else {
            innerCopy(from, to);
        }
        
        function innerCopy(from, to) {
            if (options.recursive) {
                resolvePath(from, options, function(err, rFrom){
                    resolvePath(to, options, function(err, rTo){
                        spawn("cp", {
                            args: [ "-a", rFrom, rTo ],
                            stdoutEncoding : "utf8",
                            stderrEncoding : "utf8",
                            stdinEncoding : "utf8"
                        }, function(err, child){
                            if (err) return callback(err);
                            
                            var proc = child.process;
                            var hasError;
                            
                            proc.stderr.on("data", function(d){
                                if (d) {
                                    hasError = true;
                                    callback(new Error(d));
                                }
                            });
                            proc.stdout.on("end", function() {
                                if (!hasError)
                                    callback(null, { to: to, meta: null });
                            });
                        });
                    });
                });
            }
            else {
                readfile(from, { sandbox: options.sandbox }, function (err, meta) {
                    if (err) return callback(err);
                    mkfile(to, {stream: meta.stream, sandbox: options.sandbox}, function (err, meta) {
                        callback(err, {
                            to: to,
                            meta: meta
                        });
                    });
                });
            }
        }
    }

    function symlink(path, options, callback) {
        if (!options.target) return callback(new Error("options.target is required"));
        var meta = {};
        // Get real path to target dir
        resolvePath(dirname(path), options, function (err, dir) {
            if (err) return callback(err);
            path = join(dir, basename(path));
            
            resolvePath(options.target, options, function (err, target) {
                if (err) return callback(err);
                fs.symlink(target, path, function (err) {
                    if (err) return callback(err);
                    callback(null, meta);
                });
            });
        });
    }

    function WatcherWrapper(path, options, callback) {
        var listeners  = [];
        var persistent = options.persistent;
        var timer, isDir, watcher, _self = this;
        
        function watch(callback) {
            function sendError(e) {
                if (callback)
                    return callback(e);
                else {
                    throw new Error("File does not exist");
                }
            }
            
            try {
                removeFromList();
                fileWatchers[path] = fileWatchers[path] || [];
                fileWatchers[path].push(_self);
                
                if (options.file) {
                    watcher = fs.watchFile(path, { persistent: false }, onWatchEvent);
                    watcher.close = function() {
                        removeFromList();
                        fs.unwatchFile(path);
                    };
                }
                else {
                    watcher = fs.watch(path, { persistent: false }, onWatchEvent);
                    var close = watcher.close.bind(watcher);
                    watcher.close = function() {
                        removeFromList();
                        close();
                    };
                }
                
                // without this deleting folder on windows was crashing server sometimes with EPERM error
                watcher.on("error", function(e) {
                    console.error("[Watcher error]", e, path);
                });
                
                function removeFromList() {
                    if (fileWatchers[path]) {
                        fileWatchers[path] = fileWatchers[path].filter(function(w) {
                            return w !== _self;
                        });
                        if (!fileWatchers[path].length)
                            delete fileWatchers[path];
                    }
                }
                
            } catch(e) {
                return sendError(e);
            }
            
            callback && callback(null, _self);
        }
        
        function close() {
            watcher && watcher.close();
        }
        
        // Receives watch results, uses buffering
        function onWatchEvent(event, filename) {
            // No need to buffer if we can't expect more events
            if (persistent === false)
                return handleWatchEvent(event, filename);
            
            // 350ms buffer to see if a new event comes in,
            // and grace period where we don't rely on the watchers
            clearTimeout(timer);
            timer = setTimeout(function() {
                handleWatchEvent(event, filename);
            }, 350);
            
            // Continue listening
            // This timeout fixes an eternal loop that can occur with watchers
            // But we should be save the next 350ms anyway per the above
            if (event != "delete") {
                close();
                setTimeout(function() {
                    try {
                        watch(); 
                    } catch(e) {
                        if (e.code == "ENOENT") {
                            event = "delete";
                            sendToAllListeners(event, filename);
                            clearTimeout(timer);
                        }
                    }
                }, 15);
            }
        }
        
        var handleWatchEvent = this.handleWatchEvent = function(event, filename, isVfsWrite) {
            // it is a temp file
            if (filename && filename.substr(-1) == "~" 
              && filename.charAt(0) == ".")
                return;
                
            createStatEntry(pathBasename(path), path, function(entry) {
                entry.vfsWrite = isVfsWrite || false;
                
                if (entry.err) {
                    event = "delete";
                    close();
                }
                else if (isDir) {
                    event = "directory";
                    
                    // This timeout helps when (for instance git) updates
                    // many files in a folder at the same time.
                    fs.readdir(path, function (err, files) {
                        if (err) {
                            event = "error";
                            return sendToAllListeners(event, filename, entry, err);
                        }
                        
                        var latest, i = 0;
                        function statFiles() {
                            var file = files[i];
                            if (!file) return done();
                            
                            var fullpath = join(path, file);
                            createStatEntry(file, fullpath, function(entry) {
                                files[i++] = entry;
                                
                                if (!latest || entry.mtime > latest.mtime)
                                    latest = entry;
                                
                                statFiles();
                            });
                        }
                        
                        function done() {
                            // Ignore if files is tmp file
                            if (latest && (latest.name.substr(-1) == "~" || latest.name[1] === "~")
                              && latest.name.charAt(0) == ".")
                                return;
                            
                            sendToAllListeners(event, filename, entry, files);
                        }
                        
                        statFiles();
                    });
                    return;
                }
                
                sendToAllListeners(event, filename, entry);
            });
        }

        var sendToAllListeners = this.sendToAllListeners = function(event, filename, entry, files) {
            listeners.forEach(function(fn) {
                fn(event, filename, entry, files);
            });
        };
        
        this.close = function(){
            listeners  = [];
            if (watcher) {
                watcher.removeListener("change", handleWatchEvent);
                watcher.close();
            }
        };
        
        this.on = function(name, fn){
            if (name != "change")
                watcher.on.apply(watcher, arguments);
            else {
                listeners.push(fn);
            }
        };
        
        this.removeListener = function(name, fn){
            if (name != "change")
                watcher.removeListener.apply(watcher, arguments);
            else {
                listeners.splice(listeners.indexOf(fn), 1);
            }
        };
        
        this.pause = function() {
            close();
        };
        
        this.resume = function(callback, newPath) {
            if (newPath)
                path = newPath;
            if (!listeners.length)
                return callback();
            watch(callback);
        };
        
        fs.stat(path, function (err, stat) {
            if (err) {
                callback(err);
                return sendToAllListeners("delete");
            }
            
            if (isDir === undefined)
                isDir = stat && stat.isDirectory();
            
            watch(callback);
        });
    }

    function watch(path, options, callback) {
        resolvePath(path, options, function (err, path) {
            if (isWin && isSpecialPath(path)) return callback(true);
            if (err) return callback(err);
            
            new WatcherWrapper(path, options, function(err, watcher){
                if (err) return callback(err);
                callback(null, { watcher: watcher });
            });
        });
    }
    
    /**
     * Write to a file that may be watched by a file watcher,
     * making sure its file watching events are properly sent.
     * 
     * @param {String} path                            Path of our file
     * @param {Function} callback                      Function writing to path
     * @param {Function} callback.afterWrite           Function to call when done writing
     * @param {Function} callback.afterWrite.callback  Callback of afterWrite()
     */
    function writeToWatchedFile(path, callback) {
        if (!fileWatchers[path])
            return callback(function(c) { c(); });
            
        var watchers = fileWatchers[path].slice();
        var parentDir = dirname(path) + "/";
        var dirWatchers = (fileWatchers[parentDir] || []).slice();

        watchers.forEach(function(w) {
            w.pause();
        });
        callback(done);
        
        function done(callback) {
            if (!watchers.length)
                return callback();
            
            // Notify each watcher of changes and reactivate it
            var watcher = watchers.pop();
            fs.stat(path, function(err, stat) {
                if (err || !stat) return;
                stat.vfsWrite = true;
                watcher.sendToAllListeners("change", basename(path), stat);
            });
            watcher.resume(function() {
                done(callback);
            });
        }
    }
    
    function renameWatchedFile(frompath, topath, callback) {
        var removed = [];
        Object.keys(fileWatchers).forEach(function(path) {
            if (path.slice(0, frompath.length) == frompath && (path[frompath.length] == "/" || !path[frompath.length])) {
                var watchers = fileWatchers[path].slice();
                watchers.forEach(function(w) {
                    w.pause();
                });
                removed.push({
                    relpath: path.slice(frompath.length),
                    watchers: watchers
                });
            }
        });
        fs.rename(frompath, topath, function(err) {
            var root = err ? frompath : topath;
            removed.forEach(function(x) {
                var path = root + x.relpath;
                x.watchers.forEach(function(w) {
                    w.resume(function() {
                    }, path);
                });
            });
            callback(err);
        });
    }

    function connect(port, options, callback) {
        var retries = options.hasOwnProperty('retries') ? options.retries : 5;
        var retryDelay = options.hasOwnProperty('retryDelay') ? options.retryDelay : 50;
        tryConnect();
        function tryConnect() {
            var called = false;
            var socket = net.connect(port, "127.0.0.1", function() {
                if (called) return;
                called = true;
                
                if (options.hasOwnProperty('encoding')) {
                    socket.setEncoding(options.encoding);
                }
                callback(null, {stream:socket});
            });
            socket.once("error", function (err) {
                if (err.code === "ECONNREFUSED" && retries) {
                    setTimeout(tryConnect, retryDelay);
                    retries--;
                    retryDelay *= 2;
                    return;
                }
                
                if (called) return;
                called = true;
                return callback(err);
            });
        }
    }

    function chmod(path, options, callback) {
        resolvePath(path, options, function(err, path){
            if (err) return callback(err);
            
            _execFile("chmod", [options.mode, path], {}, 
              function (err, stdout, stderr) {
                if (err) {
                    err.stderr = stderr;
                    err.stdout = stdout;
                    return callback(err);
                }
    
                callback(null, {});
            });
        });
    }
    
    function spawn(executablePath, options, callback) {
        if (waitForEnv)
            return waitForEnv.push(spawn.bind(null, executablePath, options, callback));
            
        var args = options.args || [];
        
        _setDefaultEnv(options);
        
        resolvePath(executablePath, { 
            nocheck       : 1,
            alreadyRooted : true
        }, function(err, path){
            if (err) return callback(err);
            
            var child;
            try {
                child = childProcess.spawn(path, args, options);
            } catch (err) {
                return callback(err);
            }
            if (options.resumeStdin) child.stdin.resume();
            if (options.hasOwnProperty('stdoutEncoding')) {
                child.stdout && child.stdout.setEncoding(options.stdoutEncoding);
            }
            if (options.hasOwnProperty('stderrEncoding')) {
                child.stderr && child.stderr.setEncoding(options.stderrEncoding);
            }
            
            // node 0.10.x emits error events if the file does not exist
            child.on("error", function(err) {
                child.emit("exit", 127);
            });
    
            callback(null, {
                process: child
            });
        });
    }
    
    function ptyspawn(executablePath, options, callback) {
        var args = options.args || [];
        delete options.args;
        
        _setDefaultEnv(options);
        delete options.env.TMUX;
            
        if (options.testing) {
            args.forEach(function(arg, i){
                args[i] = arg.replace(/^~/, process.env.HOME);
            });
        }
        
        resolvePath(executablePath, { 
            nocheck       : 1,
            alreadyRooted : true
        }, function(err, path){
            if (err) return callback(err);
            
            if (options.validatePath)
                fs.exists(path, check);
            else
                check(true);
                
            function check(exists){
                if (!exists) {
                    var err = new Error("ENOENT: file not found " + path);
                    err.code = "ENOENT";
                    return callback(err);
                }
                
                var proc;
                try {
                    proc = pty.spawn(path, args, options);
                    proc.on("error", function(){
                        // Prevent PTY from throwing an error;
                        // I don't know how to test and the src is funky because
                        // it tests for .length < 2. Who is setting the other event?
                    });
                    proc.resizeOrig = proc.resize;
                    proc.resize = function(cols, rows) {
                        try {
                            proc.resizeOrig(cols, rows);
                        } catch(e) {
                            console.error("error when resizing terminal", e);
                            return;
                        }
                        // todo add resize event    
                        proc.emit("data", {rows: rows, cols: cols});
                        
                        if (!tmuxWarned && !isWin) {
                            if (/v0\.([123456789]\..*|10\.(0|1|2[0-7]))/.test(process.version)) {
                                proc.emit("data", {
                                    message: "Wrong Node.js version: " + process.version, 
                                    code: "EINSTALL"
                                });
                            }
                            else if (TMUXNAME == "cloud91.6") {
                                proc.emit("data", {
                                    message: "Wrong TMUX version: 1.6", 
                                    code: "EINSTALL"
                                });
                            }
                            else if (noTmux) {
                                proc.emit("data", {
                                    message: "Please make sure TMUX is installed", 
                                    code: "EINSTALL"
                                });
                            }
                            tmuxWarned = true;
                        }
                    };
                } catch (err) {
                    return callback(err);
                }
                
                callback(null, {
                    pty: proc
                });
            }
        });
    }
    
    function escapeRegExp(str) {
        return str.replace(/[-[\]{}()*+?.,\\^$|#\s"']/g, "\\$&");
    }
    
    /**
     * @param {Boolean}   [options.kill]         First kill an existing session
     * @param {Boolean}   [options.attach]       Attach if the session exists
     * @param {Boolean}   [options.detach]       Detach immediately after starting the process. This will return a pid instead of a pty.
     * @param {Boolean}   [options.detachOthers] Detach other clients immediately after starting the process
     * @param {Boolean}   [options.fetchpid]     Return the pid of the process started in the tmux session, or -1 if it's no longer running
     * @param {Boolean}   [options.output]       Act like an output pane
     * @param {Boolean}   [options.base]         The base path to store the watch files
     */
    function tmuxspawn(ignored, options, callback) {
        var tmuxName = options.tmuxName || TMUXNAME;
        var session = options.session;
        
        function fetchPid(callback, retries){
            if (!retries) retries = 0;
            _execFile(TMUX, [
                "-u2", "-L", tmuxName, "-C",
                "list-panes", "-F", "c9-pid-#{pane_pid}-#{pane_dead}-#{pane_status}",
                "-t", session
            ], {
                maxBuffer: 1000 * 1024
            }, function(err, stdout){
                var matches = /c9-pid-(\d+)-(\d)-/.exec(stdout);
                var isDead = parseInt(matches && matches[2], 10);
                var pid = isDead ? 0 : parseInt(matches && matches[1], 10);
                
                if (!pid && !isDead && retries < 10) {
                    setTimeout(fetchPid.bind(null, callback, ++retries), 30);
                    return;
                }
                
                callback(err, { 
                    pid: pid || -1
                });
            });
        }
        
        // Fetch PID of a running process and return it
        if (options.fetchpid)
            return fetchPid(callback);
        
        // Capture the scrollback of a pane
        if (options.capturePane) {
            options = options.capturePane;
            args = [
                "-u2", // force utf and 256 color
                "-L", tmuxName,
                "capture-pane", options.joinLines !== false ? "-peJ" : "-pe",
                "-S", options.start, 
                "-E", options.end, 
                "-t", options.pane
            ];
            
            var child;
            try {
                child = childProcess.spawn(TMUX, args, options);
            } catch (err) {
                return callback(err);
            }
            child.stdout.setEncoding("utf8");
            child.stderr.setEncoding("utf8");
            
            // node 0.10.x emits error events if the file does not exist
            child.on("error", function(err) {
                child.emit("exit", 127);
            });
    
            callback(null, {
                process: child
            });
            
            return;
        }
        
        if (options.getStatus) {
            options = options.getStatus;
            var sessionId = options.id;
            var args = ["-u2", "-L", tmuxName];
            
            var paneFormat = {
                "#S"                        : "session",
                "#{pane_current_path}"      : "path",
                "#{pane_current_command}"   : "command",
                "#{pane_width}"             : "width",
                "#{pane_height}"            : "height",
                "#{history_limit}"          : "length",
                "#{history_size}"           : "line",
                "#{cursor_x}"               : "x",
                "#{cursor_y}"               : "y",
                "#{saved_cursor_x}"         : "savedX",
                "#{saved_cursor_y}"         : "savedY",
                "#{scroll_region_lower}"    : "scrollRegionLower",
                "#{scroll_region_upper}"    : "scrollRegionUpper",
                numberDataIndex             : 3,
            };
            
            var clientFormat = {
                "#{client_session}"  : "session",
                "#{client_created}"  : "created",
                "#{client_activity}" : "activity",
                "#{client_width}"    : "width",
                "#{client_height}"   : "height",
                numberDataIndex      : 1,
            };
            function getFormatString(map) {
                return Object.keys(map).filter(function(x) {
                    return x[0] == "#";
                }).join("\x01");
            }
            function getFormatObject(map, str) {
                var data = str.split("\x01");
                var result = {};
                Object.keys(map).forEach(function(key, i) {
                    if (key[0] != "#") return;
                    var val = data[i];
                    if (i >= map.numberDataIndex)
                        val = parseInt(val, 10);
                    result[map[key]] = val;
                });
                return result;
            }
            
            args.push("list-panes", "-F", getFormatString(paneFormat));
            if (sessionId)
                args.push("-t", sessionId);
            else
                args.push("-a");
            
            if (options.listClients !== false) {
                args.push(";", "list-clients", "-F", "\n" + getFormatString(clientFormat));
                if (sessionId)
                    args.push("-t", sessionId);
            }
            
            return _execFile(TMUX, args, function(e, data) {
                var panes = {};
                var clientsSection = false;
                (data || "").split("\n").forEach(function(str) {
                    if (!str)
                        return (clientsSection = true);
                        
                    var pane;
                    if (clientsSection) {
                        var client = getFormatObject(clientFormat, str);
                        pane = panes[client.session];
                        if (pane)
                            pane.clients.push(client);
                    } else {
                        pane = getFormatObject(paneFormat, str);
                        panes[pane.session] = pane;
                        pane.clients = [];
                    }
                });
                // panes.raw = data;
                if (sessionId)
                    panes = panes[sessionId];
                callback(e, {status: panes});
            });
        }
        
        // Kill the session with the same name before starting a new one
        if (options.kill) {
            if (!options.session)
                return callback(new Error("Missing session name"));

            // logToFile("Kill: " + options.session);
            
            _execFile(TMUX, 
                ["-L", tmuxName, "-C", "kill-session", "-t", options.session], 
                function(err){
                    if (!options.command)
                        return callback(err, {});
                    
                    start(); 
                });
        }
        // Attach to a session with the same name if it exists
        else if (options.attach) {
            if (!options.session)
                return callback(new Error("Missing session name"));
            
            (function findSession(retries){
                _execFile(TMUX, ["-u2", "-L", tmuxName, "list-sessions"], function(err, stdout) {
                    if (err) stdout = ""; // This happens when the tmux server has not been started yet
                
                    var re = new RegExp("^" + escapeRegExp(options.session) + ":", "m");
                    if (stdout.match(re))
                        start(true);
                    else if (options.output && retries < 100) {
                        setTimeout(findSession.bind(null, ++retries), 10);
                    }
                    else {
                        // var error = new Error("Session doesn't exist: " + options.session);
                        // error.code = "ENOSESSIONFOUND";
                        // callback(error);
                        start(false);
                    }
                });
            })(0);
        }
        // Just start a new session. This will fail if a session with that name already exists
        else 
            start();
        
        function start(attach){
            var args = [];
            
            if (!options.env) options.env = {};
            
            if (attach) {
                // logToFile("Attach: " + options.session);
                
                args = ["-u2", "-L", tmuxName, "attach", "-t", options.session];
                if (options.detachOthers) {
                    // Work around https://github.com/chjj/pty.js/issues/68
                    if (/v0\.([123456789]\..*|10\.(0|1|2[0-7]))/.test(process.version))
                        console.log("detachOthers not supported, ignoring");
                    else
                        args.push("-d");
                }
            }
            else {
                // logToFile("New: " + options.session);
                
                args = ["-u2", "-L", tmuxName, "new", "-s", options.session];
                
                if (options.terminal) {
                    args.push("export ISOUTPUTPANE=0;"
                        + (options.defaultEditor
                            ? " export EDITOR='`which c9` open --wait'; "
                            : "")
                        + BASH + " -l");
                }
                else if (options.idle) {
                    args.push(BASH + " -l -c 'printf \"\\e[01;34m[Idle]\\e[0m\\n\""
                        + "; sleep 0.1;'");
                }
                else if (options.command) {
                    args.push(BASH + " -l -c '"
                        + (
                            'trap \'printf "\\e[01;30m\\n\\nProcess exited with code: $?\\e[0m\\n"\' EXIT\n'
                            + options.command
                        ).replace(/'/g, "'\\''")
                        + "'");
                }
                
                args.push(
                    ";", "set", "-q", "-g", "status", "off",
                    ";", "set", "-q", "destroy-unattached", "off",
                    ";", "set", "-q", "mouse-select-pane", "on",
                    ";", "set", "-q", "set-titles", "on",
                    ";", "set", "-q", "quiet", "on",
                    ";", "set", "-q", "-g", "prefix", "C-b",
                    ";", "set", "-q", "-g", "default-terminal", "xterm-256color",
                    ";", "setw", "-q", "-g", "xterm-keys", "on"
                );
                
                // disable buffering of tmux output
                // old versions of tmux skip parts of output without this flag
                if (parseFloat(TMUXNAME.substr("cloud9".length)) < 2.1)
                    args.push(";", "setw", "-q", "c0-change-trigger", "0");
                
                if (options.output) {
                    args.push(
                        ";", "set", "-q", "remain-on-exit", "on",
                        ";", "setw", "-q", "-g", "aggressive-resize", "on"
                    );
                }
                
                
                if (options.detach && options.output) {
                    args.unshift("-C");
                    args.push(";", "list-panes", "-F", "c9-pid#{pane_pid}-");
                }
                if (options.detach)
                    args.push(";", "detach");
                
                options.env["LD_LIBRARY_PATH"] = (options.env["LD_LIBRARY_PATH"] 
                    ? options.env["LD_LIBRARY_PATH"] + ":" : "") + "~/.c9/local/lib";
                
                // Prevent welcome message
                options.env["ISOUTPUTPANE"] = "1";
            }
            
            run();
            
            function run(err){
                if (err) return callback(err);
                _setDefaultEnv(options);
                delete options.env.TMUX;
                
                // HACK: workaround for tmux 2.2 bug: 
                // tmux passes PATH to new sessions breaking rvm
                var sep = isWin ? ";" : ":";
                options.env.PATH = options.env.PATH.split(sep).filter(function(p) {
                    return !/\/rvm\//.test(p);
                }).join(sep);
                // ENDHACK
                
                if (options.detach && options.output) {
                    
                    return _execFile(TMUX, args, {
                        args: args,
                        name: options.name,
                        cwd: options.cwd,
                        resolve: options.resolve,
                        env: options.env
                    }, function(err, stdout) {
                        var m = /c9-pid(\d+)-/.exec(stdout);
                        var pid = parseInt(m && m[1], 10);
                        callback(err, {pid: pid});
                    });
                }
                
                ptyspawn(TMUX, {
                    args: args,
                    name: options.name,
                    cols: options.cols,
                    rows: options.rows,
                    cwd: options.cwd,
                    resolve: options.resolve,
                    env: options.env
                }, function(err, meta){
                    if (err) {
                        logToFile("TMUX ERROR: " + err.message);
                        return callback(err);
                    }
                    
                    if (!attach) {
                        meta.pty.on("data", function wait(data){
                            if (data)
                                meta.pty.removeListener("data", wait);
                            // Look for error states in plain text from tmux
                            if (data.indexOf("can't create socket") > -1) {
                                var err = new Error(data);
                                err.type = "exception";
                                err.code = "EPERM";
                                meta.pty.emit("data", err);
                            }
                        });
                    }
                    
                    // Return the pty
                    callback(null, meta);
                    
                    if (attach)
                        meta.pty.emit("data", { started: true });
                });
            }
        }
    }
    
    function PtyStream(pty, isOutput, old){
        if (old) {
            return old.attachTo(pty, isOutput);
        }
        var exited = false;
        var killed = false;
        
        this.readable = true;
        this.writable = true;
        
        this.__defineGetter__("pid", function(){
            return exited ? -1 : pty.pid; 
        });
        
        function exit(){
            if (exited) return;
            
            exited = true;
            emit("data", ["\n\x1b[1mPane is dead\x1b[H"]);
            pty.kill();
            pty.kill = function() {};
        }
        
        this.attachTo = function(newPty) {
            pty = newPty;
            exited = false;
            killed = false;
        
            this.readable = true;
            this.writable = true;

            Object.keys(events).forEach(forwardEvent);
            return this;
        }
        
        this.killtree = 
        this.kill = isOutput ? function(signal){
            // We dont want to really kill, just stop the process
            if (signal == -1) {
                if (exited)
                    emit("kill");
                else {
                    exit();
                    
                    pty.on("exit", function(){
                        emit("kill");
                    });
                }
                pty.suspended = true;
                return;
            }
            
            killed = true;
            
            // Otherwise we really kill this pty
            emit("end");
            emit("exit");
        } : function(){
            pty.kill();
            // sometimes this can be called twice from worker and from options.kill
            // pty.js doesn't like that
            pty.kill = function() {};
        };
        
        this.destroy = function(){
            return pty.destroy.apply(pty, arguments);
        };
        
        this.end = function(){
            return pty.end.apply(pty, arguments);
        };
        
        this.write = function() {
            return pty.write.apply(pty, arguments);
        };
        
        this.resize = function() {
            if (!exited)
                return pty.resize.apply(pty, arguments);
        };
        
        // this.acknowledgeWrite = function(callback) {
        //     setTimeout(callback, 50); // 50ms time to ack input, per Winstein and Balakrishnan, 2013
        // };
        
        var events = {};
        function forwardEvent(name){
            events[name] = events[name] || [];
            
            if (isOutput && (name == "exit" || name == "close" || name == "end")) {
                if (name != "exit") return;
                
                pty.on("exit", function(){
                    exit();
                });
            }
            else {
                pty.on(name, function(){
                    emit(name, arguments);
                });
            }
        }
        
        function emit(name, args){
            if (!events[name]) 
                return;
                
            events[name].forEach(function(fn){ fn.apply(pty, args); });
        }
        
        this.on = 
        this.addListener = function(name, fn){
            if (!events[name]) forwardEvent(name);
            events[name].push(fn);
        };
        
        this.off = 
        this.removeListener = function(name, fn){
            var idx = events[name].indexOf(fn);
            if (idx > -1) events[name].splice(idx, 1);
        };
        
        this.emit = emit;
    }
    
    // Same as tmuxspawn but than spawns bash or other shell, for windows
    var sessions = {};
    function bashspawn(ignored, options, callback) {
        var session;
        
        function getSessionId(){
            var id = "session" + Math.round(Math.random() * 1000);
            return sessions[id] ? getSessionId() : id;
        }
        
        // Fetch PID of a running process and return it
        if (options.fetchpid) {
            session = sessions[options.session];
            setTimeout(function() {
                callback(null, { pid: session && session.pty ? session.pty.pid : -1 });
            }, 100); // workaround for late exit message from winpty
            return;
        }
        
        // Capture the scrollback of a pane
        if (options.capturePane)
            return callback(new Error("Not Supported on Windows"));
        
        // Kill the session with the same name before starting a new one
        if (options.kill) {
            session = sessions[options.session];
            if (session && session.pty)
                session.pty.kill();
            
            if (!options.command)
                return callback(session ? null : new Error("No Session Found"), {});
            
            start(); 
        }
        // Attach to a session with the same name if it exists
        else if (options.attach) {
            if (!options.session)
                return callback(new Error("Missing session name"));
            
            session = sessions[options.session];
            if (session) {
                if (session.wait)
                    session.wait.push(callback);
                else if (session.pty && !session.pty.suspended)
                    callback(null, { pty: session.pty });
            }
            else
                start();
        }
        // Just start a new session. This will fail if a session with that name already exists
        else {
            if (options.session && sessions[options.session]) {
                callback(new Error("Session Already Started"));
            }
            
            start();
        }
        
        function start() {
            if (!options.session)
                return callback(new Error("Missing session name"));

            var args = ["-l", "-i"];
            var name = options.session || getSessionId();
            
            var session    = sessions[name] || {};
            sessions[name] = session;
            if (!session.wait) session.wait = [];
            
            if (options.idle) {
                options.command = "echo '\033[2J\033[1;1H\033[01;34m[Idle]\033[0m'";
            } else if (options.command) {
                options.command = "echo '\033[2J\033[1;1H';" + options.command
                    + ';printf "\033[01;30m\n\nProcess exited with code: $?\033[0m\n"';
            }
            
            if (options.command) {
                args.push("-c", "nodosfilewarning=1;" + options.command);
            
                var cmd = args[args.length - 1];
                args[args.length - 1] = '"' + cmd.replace(/"/g, '\\"') + '"';
            }
            
            run();
            
            function run(err){
                if (err) return callback(err);

                // Start PTY with TMUX
                ptyspawn(options.BASH || BASH, {
                    args: args,
                    name: options.name,
                    cols: options.cols,
                    rows: options.rows,
                    cwd: options.cwd,
                    resolve: options.resolve,
                    env: options.env || {}
                }, function(err, meta){
                    if (err) return callback(err);
                    
                    session.pty = meta.pty = 
                        new PtyStream(meta.pty, options.output, session.pty);
                    
                    var wait = session.wait;
                    delete session.wait;
                    wait.forEach(function(cb){ 
                        cb(null, { pty: session.pty }); 
                    });
                    
                    // Clear Session when pty ends
                    meta.pty.on("exit", function(){
                        delete sessions[name];
                    });
                    
                    // Fetch the PID if appropriate
                    if (options.detach && options.output) {
                        session.pty.on("data", function wait(data){
                            // if (data.indexOf("aggressive-resize") > -1) {
                            
                            session.pid = meta.pid = session.pty.pid;
                            callback(null, meta);
                                
                            session.pty.removeListener("data", wait);
                            // }
                        });
                        return;
                    }
                    
                    // Return the pty
                    callback(null, meta);
                });
            }
        }
    }

    function execFile(executablePath, options, callback) {
        if (waitForEnv)
            return waitForEnv.push(execFile.bind(null, executablePath, options, callback));
        
        if (isWin && execFileWin(executablePath, options, callback))
            return;
        
        _setDefaultEnv(options);
        
        resolvePath(executablePath, {
            nocheck       : 1,
            alreadyRooted : true
        }, function(err, path){
            if (err) return callback(err);
            
            _execFile(path, options.args || [], 
              options, function (err, stdout, stderr) {
                if (err) {
                    err.stderr = stderr;
                    err.stdout = stdout;
                    return callback(err);
                }
    
                callback(null, {
                    stdout: stdout,
                    stderr: stderr
                });
            });
        });
    }
    
    function execFileWin(executablePath, options, callback) {
        if (executablePath == "kill") {
            var pid = options.args && options.args[0];
            
            Object.keys(sessions).some(function(key) {
                if (sessions[key].pid == pid && sessions[key].pty) {
                    sessions[key].pty.killtree(-1);
                    return true;
                }
            });
            callback();
            return true;
        }
    }
    
    function _setDefaultEnv(options) {
        if (options.hasOwnProperty("env"))
            options.env.__proto__ = fsOptions.defaultEnv;
        else
            options.env = fsOptions.defaultEnv;
        
        // Pty is only reading from the object itself;
        var env = {};
        for (var prop in options.env)
            env[prop] = options.env[prop];
        options.env = env;
        
        if (options.cwd && options.cwd.charAt(0) == "~")
            options.cwd = options.env.HOME + options.cwd.substr(1);
        
        if (transformPath && options.cwd)
            options.cwd = transformPath(options.cwd);
    }

    function killtree(pid, options, callback) {
        var code = options.code || options.graceful ? "SIGTERM" : "SIGKILL";
        
        childrenOfPid(pid, function killList(err, pidlist){
            if (err)
                return callback(err);
            
            pidlist.forEach(function (pid) {
                // if asked to kill ourselves do that only after killing all the children
                if (pid == process.pid) {
                   return setTimeout(function() {
                       process.kill(pid, code);
                   });
                }
                try {
                    process.kill(pid, code);
                } catch(e) {
                    if (e.code == "ESRCH")
                        return; // kill may throw if the pid does not exist.
                    // todo try killing with sudo in case of "EPERM"
                }
            });
            if (options.graceful && code != "SIGKILL") {
                code = "SIGKILL";
                setTimeout(function() {
                    killList(null, pidlist);
                }, options.timeout || 800);
            } else {
                callback(null, {});
            }
        });
    }

    function childrenOfPid(pid, callback) {
        if (isWin)
            return callback(null, [pid]);
        
        _execFile("ps", ["-A", "-oppid,pid"], function(err, stdout, stderr) {
            if (err)
                return callback(err);

            var parents = {};
            stdout.split("\n").slice(1).forEach(function(line) {
                var col = line.trim().split(/\s+/g);
                (parents[col[0]] || (parents[col[0]] = [])).push(parseInt(col[1]));
            });

            function search(roots) {
                var res = roots.concat();
                for (var i = 0; i < roots.length; i++) {
                    var c = parents[roots[i]];
                    if (c) res.push.apply(res, search(c));
                }
                return res;
            }
            callback(null, search([pid]));
        });
    }

    function on(name, handler, callback) {
        if (!handlers[name]) handlers[name] = [];
        handlers[name].push(handler);
        callback && callback();
    }

    function off(name, handler, callback) {
        var list = handlers[name];
        if (list) {
            var index = list.indexOf(handler);
            if (index >= 0) {
                list.splice(index, 1);
            }
        }
        callback && callback();
    }

    function emit(name, value, callback) {
        var list = handlers[name];
        if (list) {
            for (var i = 0, l = list.length; i < l; i++) {
                list[i](value);
            }
        }
        callback && callback();
    }

    function extend(name, options, callback) {
        if (!name) {
            var err = new Error("EACCES: Invalid extension name");
            err.code = "EACCES";
            return callback(err);
        }

        var meta = {};
        // Pull from cache if it's already loaded.
        if (!options.redefine && apis.hasOwnProperty(name)) {
            var err = new Error("EEXIST: Extension API already defined for " + name);
            err.code = "EEXIST";
            return callback(err, { api: apis[name] });
        }
        
        if (options.redefine && apis[name] && apis[name].destroy)
            apis[name].destroy();

        var fn;

        // The user can pass in a path to a file to require
        if (options.file) {
            try { fn = require(options.file); }
            catch (err) { return callback(err); }
            exec(fn);
        }

        // User can pass in code as a pre-buffered string
        else if (options.code) {
            try { fn = evaluate(options.code, name); }
            catch (err) { return callback(err); }
            exec(fn);
        }

        // Or they can provide a readable stream
        else if (options.stream) {
            consumeStream(options.stream, function (err, code) {
                if (err) return callback(err);
                var fn;
                try {
                    fn = evaluate(code);
                } catch(err) {
                    return callback(err);
                }
                exec(fn);
            });
        }

        else {
            return callback(new Error("must provide `file`, `code`, or `stream` when cache is empty for " + name));
        }

        function exec(fn) {
            delete options.code;
            delete options.stream;
            delete options.file;

            fn(vfs, options, function(err, exports) {
                if (err) {
                    return callback(err);
                }
                exports.names = Object.keys(exports);
                exports.name = name;
                
                wrapDomain(exports);
                
                if (exports.on)
                    console.warn("Warning: " + name + " exports 'on' symbol that will be overwritten");
                apis[name] = exports;
                meta.api = exports;
                callback(null, meta);
            });
        }

    }

    function unextend(name, options, callback) {
        if (apis[name] && apis[name].destroy)
            apis[name].destroy();
            
        delete apis[name];
        callback(null, {});
    }

    function use(name, options, callback) {
        var api = apis[name];
        if (!api) {
            var err = new Error("ENOENT: There is no API extension named " + name);
            err.code = "ENOENT";
            return callback(err);
        }
        callback(null, {api:api});
    }

////////////////////////////////////////////////////////////////////////////////
    
    if (fsOptions.extendApi) {
        for (var i in fsOptions.extendApi) {
            extend(i, fsOptions.extendApi[i], function() {});
        }
    }
    
    return vfs;

};

// Consume all data in a readable stream and call callback with full buffer.
function consumeStream(stream, callback) {
    var chunks = [];
    stream.on("data", onData);
    stream.on("end", onEnd);
    stream.on("error", onError);
    function onData(chunk) {
        chunks.push(chunk);
    }
    function onEnd() {
        cleanup();
        callback(null, chunks.join(""));
    }
    function onError(err) {
        cleanup();
        callback(err);
    }
    function cleanup() {
        stream.removeListener("data", onData);
        stream.removeListener("end", onEnd);
        stream.removeListener("error", onError);
    }
}

// node-style eval
function evaluate(code, name) {
    var exports = {};
    var module = { exports: exports };
    var fn = vm.runInThisContext(
        "(function(require, exports, module, __dirname, __filename) {"
            + code
            + "})"
        , name || "dynamic-" + Date.now().toString(36));
    fn(require, exports, module, "", "");
    return module.exports;
}

// Calculate a proper etag from a nodefs stat object
function calcEtag(stat) {
  return (stat.isFile() ? '': 'W/') + '"' + (stat.ino || 0).toString(36) + "-" + stat.size.toString(36) + "-" + stat.mtime.valueOf().toString(36) + '"';
}

function uid(length) {
    return (crypto
        .randomBytes(length)
        .toString("base64")
        .slice(0, length)
        .replace(/[+\/]+/g, "")
    );
}

function tmpFile(baseDir, prefix, suffix) {
    return join(baseDir, [prefix || "", uid(20), suffix || ""].join(""));
}

});


define('simple-mime', function (module, exports) {

// A simple mime database.
var types;
module.exports = function setup(defaultMime) {
  return function getMime(path) {
    path = path.toLowerCase().trim();
    var index = path.lastIndexOf("/");
    if (index >= 0) {
      path = path.substr(index + 1);
    }
    index = path.lastIndexOf(".");
    if (index >= 0) {
      path = path.substr(index + 1);
    }
    return types[path] || defaultMime;
  };
};

// Borrowed and passed around from who knows where, last grabbed from connect.
types = {
  "3gp": "video/3gpp",
  a: "application/octet-stream",
  ai: "application/postscript",
  aif: "audio/x-aiff",
  aiff: "audio/x-aiff",
  asc: "application/pgp-signature",
  asf: "video/x-ms-asf",
  asm: "text/x-asm",
  asx: "video/x-ms-asf",
  atom: "application/atom+xml",
  au: "audio/basic",
  avi: "video/x-msvideo",
  bat: "application/x-msdownload",
  bin: "application/octet-stream",
  bmp: "image/bmp",
  bz2: "application/x-bzip2",
  c: "text/x-csrc",
  cab: "application/vnd.ms-cab-compressed",
  can: "application/candor",
  cc: "text/x-c++src",
  chm: "application/vnd.ms-htmlhelp",
  "class": "application/octet-stream",
  com: "application/x-msdownload",
  conf: "text/plain",
  cpp: "text/x-c",
  crt: "application/x-x509-ca-cert",
  css: "text/css",
  csv: "text/csv",
  cxx: "text/x-c",
  deb: "application/x-debian-package",
  der: "application/x-x509-ca-cert",
  diff: "text/x-diff",
  djv: "image/vnd.djvu",
  djvu: "image/vnd.djvu",
  dll: "application/x-msdownload",
  dmg: "application/octet-stream",
  doc: "application/msword",
  dot: "application/msword",
  dtd: "application/xml-dtd",
  dvi: "application/x-dvi",
  ear: "application/java-archive",
  eml: "message/rfc822",
  eps: "application/postscript",
  exe: "application/x-msdownload",
  f: "text/x-fortran",
  f77: "text/x-fortran",
  f90: "text/x-fortran",
  flv: "video/x-flv",
  "for": "text/x-fortran",
  gem: "application/octet-stream",
  gemspec: "text/x-script.ruby",
  gif: "image/gif",
  gyp: "text/x-script.python",
  gypi: "text/x-script.python",
  gz: "application/x-gzip",
  h: "text/x-chdr",
  hh: "text/x-c++hdr",
  htm: "text/html",
  html: "text/html",
  ico: "image/vnd.microsoft.icon",
  ics: "text/calendar",
  ifb: "text/calendar",
  iso: "application/octet-stream",
  jar: "application/java-archive",
  java: "text/x-java-source",
  jnlp: "application/x-java-jnlp-file",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  js: "application/javascript",
  json: "application/json",
  less: "text/css",
  log: "text/plain",
  lua: "text/x-script.lua",
  luac: "application/x-bytecode.lua",
  makefile: "text/x-makefile",
  m3u: "audio/x-mpegurl",
  m4v: "video/mp4",
  man: "text/troff",
  manifest: "text/cache-manifest",
  markdown: "text/x-markdown",
  mathml: "application/mathml+xml",
  mbox: "application/mbox",
  mdoc: "text/troff",
  md: "text/x-markdown",
  me: "text/troff",
  mid: "audio/midi",
  midi: "audio/midi",
  mime: "message/rfc822",
  mml: "application/mathml+xml",
  mng: "video/x-mng",
  mov: "video/quicktime",
  mp3: "audio/mpeg",
  mp4: "video/mp4",
  mp4v: "video/mp4",
  mpeg: "video/mpeg",
  mpg: "video/mpeg",
  ms: "text/troff",
  msi: "application/x-msdownload",
  odp: "application/vnd.oasis.opendocument.presentation",
  ods: "application/vnd.oasis.opendocument.spreadsheet",
  odt: "application/vnd.oasis.opendocument.text",
  ogg: "application/ogg",
  p: "text/x-pascal",
  pas: "text/x-pascal",
  pbm: "image/x-portable-bitmap",
  pdf: "application/pdf",
  pem: "application/x-x509-ca-cert",
  pgm: "image/x-portable-graymap",
  pgp: "application/pgp-encrypted",
  pkg: "application/octet-stream",
  pl: "text/x-script.perl",
  pm: "text/x-script.perl-module",
  png: "image/png",
  pnm: "image/x-portable-anymap",
  ppm: "image/x-portable-pixmap",
  pps: "application/vnd.ms-powerpoint",
  ppt: "application/vnd.ms-powerpoint",
  ps: "application/postscript",
  psd: "image/vnd.adobe.photoshop",
  py: "text/x-script.python",
  qt: "video/quicktime",
  ra: "audio/x-pn-realaudio",
  rake: "text/x-script.ruby",
  ram: "audio/x-pn-realaudio",
  rar: "application/x-rar-compressed",
  rb: "text/x-script.ruby",
  rdf: "application/rdf+xml",
  roff: "text/troff",
  rpm: "application/x-redhat-package-manager",
  rss: "application/rss+xml",
  rtf: "application/rtf",
  ru: "text/x-script.ruby",
  s: "text/x-asm",
  sgm: "text/sgml",
  sgml: "text/sgml",
  sh: "application/x-sh",
  sig: "application/pgp-signature",
  snd: "audio/basic",
  so: "application/octet-stream",
  svg: "image/svg+xml",
  svgz: "image/svg+xml",
  swf: "application/x-shockwave-flash",
  t: "text/troff",
  tar: "application/x-tar",
  tbz: "application/x-bzip-compressed-tar",
  tci: "application/x-topcloud",
  tcl: "application/x-tcl",
  tex: "application/x-tex",
  texi: "application/x-texinfo",
  texinfo: "application/x-texinfo",
  text: "text/plain",
  tif: "image/tiff",
  tiff: "image/tiff",
  torrent: "application/x-bittorrent",
  tr: "text/troff",
  ttf: "application/x-font-ttf",
  txt: "text/plain",
  vcf: "text/x-vcard",
  vcs: "text/x-vcalendar",
  vrml: "model/vrml",
  war   : "application/java-archive",
  wav   : "audio/x-wav",
  webapp: "application/x-web-app-manifest+json",
  webm: "video/webm",
  wma: "audio/x-ms-wma",
  wmv: "video/x-ms-wmv",
  wmx: "video/x-ms-wmx",
  wrl: "model/vrml",
  wsdl: "application/wsdl+xml",
  xbm: "image/x-xbitmap",
  xhtml: "application/xhtml+xml",
  xls: "application/vnd.ms-excel",
  xml: "application/xml",
  xpm: "image/x-xpixmap",
  xsl: "application/xml",
  xslt: "application/xslt+xml",
  yaml: "text/yaml",
  yml: "text/yaml",
  zip: "application/zip"
};


});


define('vfs-socket/worker', function (module, exports) {

var inherits = require('util').inherits;
var smith = require('smith');
var Agent = smith.Agent;
var Stream = require('stream').Stream;

exports.smith = smith;
exports.Worker = Worker;

// Worker is a smith.Agent that wraps the vfs api passed to it. It works in
// tandem with Consumer agents on the other side.
function Worker(vfs) {
    Agent.call(this, {

        // Endpoints for writable streams at meta.stream (and meta.process.stdin)
        write: write,
        end: end,

        // Endpoint for readable stream at meta.stream (and meta.process.{stdout,stderr})
        destroy: destroy,
        resume: resume,
        pause: pause,

        // Endpoints for readable streams at options.stream
        onData: onData,
        onEnd: onEnd,

        // Endpoint for writable streams at options.stream
        onClose: onClose,

        // Endpoints for processes at meta.process
        unref: unref,
        kill: kill,

        // Endpoints for processes at meta.pty
        resize: resize,

        // Endpoint for watchers at meta.watcher
        close: closeWatcher,

        // Endpoint for apis at meta.api
        call: call,

        // Endpoints for vfs itself
        subscribe: subscribe,
        unsubscribe: unsubscribe,
        emit: vfs.emit,

        // special vfs-socket api
        ping: ping,

        // Route other calls to the local vfs instance
        resolve:    route("resolve"),
        stat:       route("stat"),
        metadata:   route("metadata"),
        readfile:   route("readfile"),
        readdir:    route("readdir"),
        mkfile:     route("mkfile"),
        mkdir:      route("mkdir"),
        mkdirP:     route("mkdirP"),
        appendfile: route("appendfile"),
        rmfile:     route("rmfile"),
        rmdir:      route("rmdir"),
        rename:     route("rename"),
        copy:       route("copy"),
        chmod:      route("chmod"),
        symlink:    route("symlink"),
        watch:      route("watch"),
        connect:    route("connect"),
        spawn:      route("spawn"),
        killtree:   route("killtree"),
        pty:        route("pty"),
        tmux:       route("tmux"),
        execFile:   route("execFile"),
        extend:     route("extend"),
        unextend:   route("unextend"),
        use:        route("use")

    });

    var proxyStreams = {};
    var streams = {};
    var watchers = {};
    var processes = {};
    var apis = {};
    var handlers = {};
    var remote = this.remoteApi;

    function subscribe(name, callback) {
        handlers[name] = function (value) {
            remote.onEvent && remote.onEvent(name, value);
        };
        vfs.on(name, handlers[name], callback);
    }

    function unsubscribe(name, callback) {
        var handler = handlers[name];
        if (!handler) return;
        delete handlers[name];
        vfs.off(name, handler, callback);
    }

    // Resume readable streams that we paused when the channel drains
    // Forward drain events to all the writable proxy streams.
    this.on("drain", function () {
        Object.keys(streams).forEach(function (id) {
            var stream = streams[id];
            if (stream.readable && stream.resume) stream.resume();
        });
        Object.keys(proxyStreams).forEach(function (id) {
            var stream = proxyStreams[id];
            if (stream.writable) stream.emit("drain");
        });
    });

    // Cleanup streams, proxy streams, proxy processes, and proxy apis on disconnect.
    this.on("disconnect", function (err) {
        if (!err) {
            err = new Error("EDISCONNECT: vfs socket disconnected");
            err.code = "EDISCONNECT";
        }
        Object.keys(processes).forEach(function (pid) {
            var process = processes[pid];
            if (!process.unreffed)
                process.kill();
            delete processes[pid];
        });
        Object.keys(streams).forEach(function (id) {
            var stream = streams[id];
            stream.emit("close", err);
        });
        Object.keys(proxyStreams).forEach(onClose);
        Object.keys(watchers).forEach(function (id) {
            var watcher = watchers[id];
            delete watchers[id];
            watcher.close();
        });
    });
    
    function makeStreamProxy(token) {
        var stream = new Stream();
        var id = token.id;
        stream.id = id;
        proxyStreams[id] = stream;
        if (token.hasOwnProperty("readable")) stream.readable = token.readable;
        if (token.hasOwnProperty("writable")) stream.writable = token.writable;

        if (stream.writable) {
            stream.write = function (chunk) {
                return remote.write(id, chunk);
            };
            stream.end = function (chunk) {
                if (chunk) remote.end(id, chunk);
                else remote.end(id);
            };
        }
        if (stream.readable) {
            stream.destroy = function () {
                remote.destroy(id);
            };
            stream.resume = function () {
                remote.resume(id);
            };
            stream.pause = function () {
                remote.pause(id);
            };
        }

        return stream;
    }

    var nextStreamID = 1;
    function storeStream(stream) {
        if (stream.token)
            return stream.token;
        
        nextStreamID = (nextStreamID + 1) % 10000;
        while (streams.hasOwnProperty(nextStreamID)) { nextStreamID = (nextStreamID + 1) % 10000; }
        var id = nextStreamID;
        streams[id] = stream;
        stream.id = id;
        stream.on("error", function(err) {
            remote.onError && remote.onError(id, err);
        });
        if (stream.readable) {
            stream.on("data", function (chunk) {
                // remote can be disconnected while data still comes in
                if (remote.onData && remote.onData(id, chunk) === false) {
                    stream.pause && stream.pause();
                }
            });
            stream.on("end", function (chunk) {
                delete streams[id];
                remote.onEnd && remote.onEnd(id, chunk);
            });
        }
        stream.on("close", function () {
            delete streams[id];
            if (remote.onClose)
                remote.onClose(id);
        });
        var token = {id: id};
        stream.token = token;
        if (stream.hasOwnProperty("readable")) token.readable = stream.readable;
        if (stream.hasOwnProperty("writable")) token.writable = stream.writable;
        return token;
    }

    function storeProcess(process, onlyPid) {
        var pid = process.pid;
        if (processes.token)
            return onlyPid ? process.pid : process.token;
        
        processes[pid] = process;
        process.on("exit", function (code, signal) {
            delete processes[pid];
            remote.onExit && remote.onExit(pid, code, signal);
        });
        process.on("close", function () {
            delete processes[pid];
            if (!onlyPid) {
                delete streams[process.stdout.id];
                delete streams[process.stderr.id];
                delete streams[process.stdin.id];
            }
            remote.onProcessClose && remote.onProcessClose(pid);
        });
        
        process.kill = function(code, callback) {
            vfs.killtree(pid, {
                code: code
            }, callback || function() {});
        };
        
        var token = {pid: pid};
        process.token = token;

        if (onlyPid)
            return pid;

        token.stdin = storeStream(process.stdin);
        token.stdout = storeStream(process.stdout);
        token.stderr = storeStream(process.stderr);
        return token;
    }
    
    function storePty(pty) {
        if (!pty || processes[pty.pid] == pty) // Pty is returned twice
            return pty && pty.token;
        
        var pid = storeProcess(pty, true); delete pty.token;
        
        if (!pty.resume && pty.socket && pty.socket.resume)
            pty.resume = pty.socket.resume.bind(pty.socket);
            
        if (!pty.pause && pty.socket && pty.socket.pause)
            pty.pause = pty.socket.pause.bind(pty.socket);
        
        var token = storeStream(pty); delete pty.token;
        token.pid = pid;
        pty.token = token;
        
        pty.on("kill", function () {
            remote.onPtyKill && remote.onPtyKill(pid);
        });
        
        return token;
    }

    var nextWatcherID = 1;
    function storeWatcher(watcher) {
        do {
            nextWatcherID = (nextWatcherID + 1) % 10000;
        } while (watchers.hasOwnProperty(nextWatcherID));
        var id = nextWatcherID;
        watchers[id] = watcher;
        watcher.id = id;
        watcher.on("change", function (event, filename, stat, files) {
            remote.onChange && remote.onChange(id, event, filename, stat, files);
        });
        var token = {id: id};
        return token;
    }

    function storeApi(api) {
        var name = api.name;
        apis[name] = api;
        var token = { name: name, names: api.names };
        return token;
    }

    // Remote side writing to our local writable streams
    function write(id, chunk) {
        // They want to write to our real stream
        var stream = streams[id];
        if (!stream) return;
        stream.write(chunk);
    }
    function destroy(id) {
        var stream = streams[id];
        if (!stream) return;
        delete streams[id];
        
        if (!stream.destroy) {
            // Ignore; e.g. memory streams don't usually have this
        }
        else if (typeof stream.destroy != "function") {
            console.trace("##### WEIRD STREAM: ", stream, typeof stream.destroy, typeof stream.close);
        }
        else {
            stream.destroy();
        }
    }
    function end(id, chunk) {
        var stream = streams[id];
        if (!stream) return;
        delete streams[id];
        if (chunk) stream.end(chunk);
        else stream.end();
    }
    function resume(id) {
        var stream = streams[id];
        if (!stream) return;
        return stream.resume && stream.resume();
    }
    function pause(id) {
        var stream = streams[id];
        if (!stream) return;
        return stream.pause && stream.pause();
    }

    function kill(pid, code) {
        var process = processes[pid];
        if (!process) return;
        process.kill(code);
    }
    
    function unref(pid) {
        var process = processes[pid];
        if (!process) return;
        process.unref();
        process.unreffed = true;
    }

    function resize(pid, cols, rows) {
        var process = processes[pid];
        if (!process) return;
        
        // Resize can throw
        try { process.resize(cols, rows); }
        catch(e) {}
    }

    function closeWatcher(id) {
        var watcher = watchers[id];
        if (!watcher) return;
        delete watchers[id];
        watcher.close();
    }
    
    /**
     * Add additional timing info to any "ping" call.
     */
    function wrapPingCall(name, fnName, args) {
        if (name === "ping" && fnName === "ping" && args[0] === "serverTime" && args.length === 2) {
            var start = Date.now();
            var cb = args[1];
            
            args[1] = function(err, payload) {
                if (err) return cb(err);
                cb(null, {
                    serverTime: Date.now() - start
                });
            };
        }
    }

    function call(name, fnName, args) {
        var api = apis[name];
        if (!api) return;
        
        wrapPingCall(name, fnName, args);

        // If the last arg is a function, assume it's a callback and process it.
        if (typeof args[args.length - 1] == "function") {
            var callback = args[args.length - 1];
            args[args.length - 1] = function (err, meta) {
                if (err || (meta && typeof meta === "object")) {
                    return processCallback(err, meta, callback);
                }
                callback(err, meta);
            };
        }

        api[fnName].apply(api, args);
    }

    function onData(id, chunk) {
        var stream = proxyStreams[id];
        if (!stream) return;
        stream.emit("data", chunk);
    }
    function onEnd(id, chunk) {
        var stream = proxyStreams[id];
        if (!stream) return;
        // TODO: not delete proxy if close is going to be called later.
        // but somehow do delete proxy if close won't be called later.
        delete proxyStreams[id];
        stream.emit("end", chunk);
    }
    function onClose(id) {
        var stream = proxyStreams[id];
        if (!stream) return;
        delete proxyStreams[id];
        stream.emit("close");
    }

    // Can be used for keepalive checks.
    function ping(callback) {
        callback();
    }

    function processCallback(err, meta, callback) {
        // Make error objects serializable
        var nerr;
        if (err) {
            nerr = {
                stack: process.pid + ": " + err.stack
            };
            if (err.hasOwnProperty("code")) nerr.code = err.code;
            if (err.hasOwnProperty("message")) nerr.message = err.message;
            if (err.hasOwnProperty("stdout")) nerr.stdout = err.stdout;
            if (err.hasOwnProperty("stderr")) nerr.stderr = err.stderr;
            if (!meta)
                return callback(nerr);
        }
        var token = {};
        var keys = Object.keys(meta || {});
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            if (meta[key] == undefined)
                continue;
            switch (key) {
                case "stream": token.stream = storeStream(meta.stream); break;
                case "process": token.process = storeProcess(meta.process); break;
                case "pty": token.pty = storePty(meta.pty); break;
                case "watcher": token.watcher = storeWatcher(meta.watcher); break;
                case "api": token.api = storeApi(meta.api); break;
                default: token[key] = meta[key]; break;
            }
        }
        // Call the remote callback with the result
        callback(nerr, token);
    }

    function route(name) {
        return function wrapped(path, options, callback) {
            if (typeof callback !== "function") {
                console.error(name + ": callback must be function", path, options);
                return;
            }
            // Call the real local function, but intercept the callback
            if (options.stream) {
                options.stream = makeStreamProxy(options.stream);
            }
            // TODO: client can kill server by sending path=null !
            if (path === null || path === undefined) {
                console.error("refusing to process invalid request", path, options);
                var err = new Error("refusing to process invalid request: missing path");
                err.code = "EINVALIDPATH";
                return callback(err);
            }

            vfs[name](path, options, function (err, meta) {
                processCallback(err, meta, callback);
            });
        };
    }
}
inherits(Worker, Agent);

});


define('vfs-ssh/slave', function (module, exports) {

module.exports = function (config, callback) {

    process.title = "vfs-worker " + JSON.stringify(config);
    var Worker = require('vfs-socket/worker').Worker;
    var vfsLocal = require('vfs-local')(config);
    
    var worker = new Worker(vfsLocal);
    worker.connect([process.stdin, process.stdout], callback);
    worker.on("disconnect", function () {
        process.removeListener("SIGINT", intHandler);
        process.removeListener("SIGTERM", termHandler);
        process.removeListener("uncaughtException", exceptionHandler);
        
        vfsLocal.killtree(process.pid, {}, function(err, pidlist){
            if (err) {
                console.error(err.stack);
                process.exit();
            }
        });
    });

    process.on("SIGINT", intHandler);
    process.on("SIGTERM", termHandler);
    process.on("uncaughtException", exceptionHandler);

    function intHandler() {
        cleanup(new Error("Received unexpected signal: SIGINT"), 1);
    }
    function termHandler() {
        cleanup(new Error("Received unexpected signal: SIGTERM"), 2);
    }
    function exceptionHandler(err) {
        cleanup(err, 3);
    }
    
    function cleanup(err, code) {
        console.log(process.pid, "Unhandled exception", (err.message || err).toString(), err.stack);
        
        // give some time to send last packages
        setTimeout(function() {
            worker.disconnect(err);
            
            // give some time to close connection
            setTimeout(function() {
                process.exit(code);
            }, 500);
        }, 200);
    }
};

});
